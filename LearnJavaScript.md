# Конспект по JS  

## Подключение
Для Js брузер является средой разработки  
Скрипты пишутся в теге 
```html
<script>
   let myMessage = 'qqAll'
</script>
```
Ссылкой на файл
```html
<script src="../script.js">
   // а здесь весь код будет игнорироватся
</script>
```  
# Основы
## Структура кода
Инструкции - это синтаксические конструкции и команды, которые выполняют действия.  
Инструкции отделяются ;.  
При переходе на новую строку js сам ставит ; 
```javascript
alert('hello')
alert('world')
// все будет работать
```
Однако есть моменты где js не распознает такие неявные ;
```javascript
alert(3 +
1
+ 2);
//код выведет 6 однако как мы видим ; здесь не учлась
//в таком примере повезло и код нормально работает но могут быть и такие ситуации
alert(`Hello`)

[1, 2].forEach(alert);
// код выведет hello и дальше ошибку, так случилось потому что js не ставит ; перед [] скобками и код выполняется как одна инструкция
```
## Строгий режим use strict  

"use strict" - строгий режим включает новые функции и изменения предыдущих начиная с EcmaScript5.
```javascript
"use strict"
console.log(blabala);
```  
"use strict" можно поставить в начале большинства видов функций. Это позволяет включить строгий режим только в конкретной функции. Но обычно люди используют его для всего файла.  

Нет никакого способа отменить строгий режим как только в него осуществлен вход выйти уже нельзя.  
Консоль браузера так же находится в строгом режиме  
# Переменные 
**Переменные - это именованные контейнеры для хранения данных к примеру данных о товарах, посетителях и т.д.**
```javascript
// создаем переменную
let message;

message = 'Hello'; // с помощью оператора присвоения присваиваем ей строку
// строка сохраняется в области памяти связанной с переменной

let message = 'Hello' // стандартный краткий способ

let message = 'hello';
let name = 'wasya';
let age = 20;
// тоже самое можно записать как
let message = 'hello',
   name = 'wasya',
   age = 20;
// или даже вот в таком виде
let message = 'hello'
   , name = 'wasya'
   , age = 20;
```
Var не использовать!
```javascript
// значение в let можно менять сколько угодно раз
let message;
message = 'Hello!';

messagge = 'World';//значение поменяно
console.log(message)
// Выведет World
// страые данные удаляются при изменении значения
//Данные в переменных можно копировать
let hello = 'Hellow World';

let message
//Копируем значение Hello World
message = hello;
//теперь обе переменные содержат одинаковые данные
```
Переменная может быть обьявлена лишь однажды.
В JavaScript есть два ограничения, касающиеся имён переменных:
- Имя переменной должно содержать только буквы, цифры или символы $ и _.  
- Первый символ не должен быть цифрой.  

Создание переменной без использования use strict
```javascript
// заметка: "use strict" в этом примере не используется

num = 5; // если переменная "num" раньше не существовала, она создаётся

alert(num); // 5
```
В строгом режиме это приводит к ошибке
```javascript
"use strict";

num = 5; // ошибка: num is not defined
```  
## константы
Пишется как const 
ОТличие от let в том что const изменить нельзя кроме пары исключений
```javascript
const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
```
**Константы в верхнем регистре**
Распространены для замены труднозапоминаемым названиям а так же к значениям которые уже определены к примеру для цвета
```javascript
const COLOR_RED = '#F00';
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
// еще пример 
const BIRTHDAY = '18.04.1992'

const age = someCode(birthday);
// из этого примера следует что день рождения жестко константен он точно не изменится, а вычисляемая константа age постоянно будет менятся хоть это и тоже константа, она будет постоянно вычислятся
```
По итогу мы можем использовать для хранения данных ключевые слова:
- let
- var(обычно не использовать вообще)
- const
# Типы данных
Любое значение в js относится к данным какого либо типа
- number
- string
- boolean
- object
- undefined
- null
- bigInt
- symbol

### Число
```javascript
let n = 12;
n = 12.345;
//Для чисел существуетмножество операторов так же есть мпециальные значения
// бесконечности infinity/ -infinity.
// Если мы получаем ошибку - NaN
let n = 1 / 0;
// infinity
let notNumber = 'nonumber' / 2;
// NaN такое будет ошибкой 
```
### BigInt
Тип данных Number не может содержать числа больше (253-1) (т. е. 9007199254740991).  
Тип данных BigInt был добавлен для работы с гигантскими числами.
```javascript
const bignumber = 43290145439584938321321321321n;
// символ n в конце обязателен он указывает что это BigInt
```
### Строка
Срока в js заключается в ковычки
```javascript
let str = 'Hi';
let str2 = "И такие тоже норм";
let backstr = `Обратные ковычки позволяют вписывать переменные ${str}`;
```
### Булевый тип  
Может принимать лишь 2 значения true и false
```javascript
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено

// может быть результатом сравнения
let thatRight = 58 < 12;
console.log(thatRight);
// Выведет False
```
### null
Формирует отдельный тип который содержит null -ничего
```javascript
let age = null;
console.log(age);
// выведет null
```
### undefined
Такой тип означает что значение не присвоено.
```javascript
let age;
console.log(age);
//выведет undefined

// технически undefined можно присвоить любому значению
let age = 123;

// изменяем значение на undefined
age = undefined;

alert(age); // "undefined"
```
Однако обычно используют null для присвоения пустого или неизвестного значения. Undefined обычно используют для проверок
### Обьекты и Символы
Тип обьект - особенный он не примитивен как все предыдущие типы данных , в обьектах храянятся коллекции данных или более сложные структуры.  
Тип **Symbol** ипользуется для создания уникальных итендификаторов в обьектах.
## Оператор typeof
Выводит тип данных переменной   
Синтаксис оператора  typeof x;  
Синтаксис функции typeof(x);
```javascript
typeof undefined // undefined
typeof 0 // number
typeof 10n // bigint
typeof true // boolean
typeof 'foo' // string
typeof [1, 2, 3] // object
typeof Symbol(id) // symbol
typeof Math // object
typeof null //object но null не является обьектом, это официально признанная ошибка!!
typeof alert() // function Хотя нет такого типа данных, typeof по особому обрабатывает alert и возвращает то чем оно является вместо типа данных.
```  
# Взаимодействие с браузером alert, prompt, confirm
## alert
```javascript
alert(`hello`);
// вызывает модальное окно(небольшое окно с сообщением)
```
## prompt
Функция prompt имеет 2 аргумента
```javascript
result = prompt(title,[deafault]);
//отобразит окно с полем воода и кнопками ок, отмена
// title - текст для оттображения в окне
// default - необязательный параметр,устанавливает начальное значение в поле ввода
```  

Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр необязательный.  
То что введет пользователь будет примвоено переменной result.
Если пользователь нажмет кнопку отмена будет присвоено null.  
```javascript
let age = prompt(`сколько вам лет?`, 100);
alert(`вам ${age} лет`)
```  
**Для Internet Explorer**  
Второй параметр является необязательным, но если не указать его, то Internet Explorer вставит строку "undefined" в поле для ввода.  
## confirm 
```javascript
result = confirm(`question?`);
// представляет собой модальное окно с вопросом и кнопками ок отмена
// результат true если нажата кнопка ОК, false в других случаях  
let youThere = confirm(`are you there?`);
alert(youThere);
// Вернет true если ОК
```  
**Итого** мы можем взаимодейсвовать с браузером при помощи функций:  
- alert - показывает сообщение;  
- prompt - показывает сообщение, текстовое поле и кнопки ок/отмена, присваивает null если была зажата esc или отмена;  
- confirm - показывает сообщение и кнопки ок/отмена, присваивает булевые значения;  
  
# Преобразование типов  
Чаще всего операторы автоматически сводят данные к нужному типу(alert к строке, математические операторы к числам)  
## Строковое преобразование  
```javascript
let value = true; // boolean
alert(typeof value);

value = String(value); // теперь value это строка true
alert(typeof value); // string
```  
## Численное преобразование  
```javascript
alert(`6` / `2`);
// 3 строка преобразовалась в число.  
let str = `123`;//string
let num = Number(str); // число 123 с типом number 
let age = Number(`Любая строка кроме числа`); 
alert(age);// NaN - преобразование неудалось
```
Правила численного преобразования  
undefined => NaN    
null => 0  
true/false => 1/0  
string => пробельные символы по краям обрезаются. Далее если остается пустая строка то 0, если в строке число, то мы получим этоже число в числовом формате, если это все буквы то будет ошибка NaN.  
```javascript
alert( Number(`  123  `)); // 123, (без пробелов по краям)  
alert( Number(`123z`)); // NaN, ошибка на символе z  
alert( Number(true)); // 1  
alert( number(false)); // 0
```  
## Логическое преобразование  
Правило логического преобразования  
- Все значения логически пустые, как 0, null, undefined и NaN становятся false;
- Все остальное - true;  

```javascript
alert( Boolean(1) ); // true  
alert( Boolean(0) ); // false
alert( Boolean(`Hi`) ); // true
alert( Boolean(``) ); // false  
```  
**!!** Строчка с нулем '0' - тоже true.  
**Итого** Существует 3 широко используемых преобразования: строковое, численное и логическое.  
# Базовые операторы, математика  
Базовые - * + - / и т.д.  
## "Унарный" "бинарный" "операнд"  
**Операнд** - то к чему применяется оператор, в умножении 5 * 2 есть два операнда.  
**Унарный** - оператор, который применяется к одному операнду к примеру:
```javascript
let x = 1;  
x = -x;
alert(x); // -1 , применение минуса в унарной форме
```  
**Бинарный** - оператор применяемый к двум операндам.  
```javascript
let x = 1,
    y = 3;
alert(y - x); // 2, бинарный минус вычел значения
// формально унарный минус и бинарный являются двумя разными операторами.
```  
## Математика  
Поддерживает следущие операторы:
- Сложение + ;
- Вычитание - ;  
- Умножение * ;  
- Деление / ; 
- Взятие остатка от деления % ;
- Возведение в степень ** ;  

```javascript
alert(5 % 2): // взятие остатка от деления 5 / 2 (остаток 1);  
alert(2 ** 2); // 4 - 2 умножается на себя 2 раза  
alert(2 ** 4); // 16 2 умножается на себя 4 раза
```  
Квадратный корень  
```javascript
alert(4 ** (1/2)); // 2, 4 возведенная в 1/2 степень эквивалентно взятию корня из 4  
alert(8 ** (1/3)); // 2 , эквивалентно взятию кубического корня.  
```  
## Сложение строк при помощи бинарного +  
```javascript
let s = `моя` + `срока`;  
alert(s) // моя строка
// Если хотябы один операнд является строкой второй будет так же в неее преобразован  
alert(`1` + 2); // "12"
alert(`2` + 1); // "21"  
//Однако 
alert(2 + 2 + `1`); // "41", но не "221"
// операторы работают один за другим изначально, первый бинарный оператор сложил две двойки и получил 4 а второй сложил со строкой один и все преобразовалось в строку "41".
```
Сложение и преобразование строк - особенность бинарного плюса, другие операторы работают только с числами и всегда преобразуют операнды в числа. 
```javascript
alert(6 - `2`); // 4, двойка привелась к числу.
alert(`6` / `2`); // 3 оба операнды привелись к числу.
```
## Приведение к числу Унарный +  
Унарный плюс не проводит никаких действий с числами, но если операнд не число он его преобразует в число.
```javascript
let x = 1;
alert(+x); // 1, ничего не изменилось.  

let y = -2;  
alert(+y) // -2 
// преобразование
alert( +true ) // 1
alert( +"" ); // 0 
```
По сути это тоже самое что и Number(..), но короче.
### на практике  
```javascript  
// представим что нам нужно сложить два значения взятые из HTML формы( а значения из таких форм являются строками)
let apples = 7
let oranges = 4

alert(apples + oranges); // "74" - это явно не то что мы хотели получить  
// используем унарный плюс  
alert(+apples + +oranges) // 11 - так на много лучше.
```  
## Приоритет операторов  
В принципе все работает так же как и в математике скобки - высший приоритет, умножение, плюс/ минус.  
Однако унарные знаки имеют приоритет ниже скобок но в тоже время выше умножения.  
Всю приоритетность можно посмотреть в таблице на [MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence);  
## Присваивание  
```javascript
let x = 2 * 2 + 1;

alert( x ); // 5
//У присваивания практически самый низкий приоритет, именно поэтому изначально происходит арифметика, а позже присваевание.
// Присваивание не является конструкцией языка, а оператором и так же как остальные операторы возвращает значения, благодаря этому оператор = можно использовать как часть выражения.  
let a = 1
let b = 2
let c = 3 - (a = b + 1);

alert(a); // вернет 3
alert(c); // вернет 0   
// Присваивание по цепочке  
let a, b, c;

a = b = c = 2 + 2;
alert(a);
alert(b);
alert(c);  
// 4 
```  
## Сокращенная арифметика с присваеванием  
```javascript
let n = 2
n = n + 5
n = n * 2
// эту запись можно ускорить при помощи скоращенных операторов +=, *=
let n = 2
n += 5
n*= 2
// 14, работает так же но короче.
// подобные краткие формы существуют и как /= и -=
//приоритет выполнения тот же самый
let n = 2
n *= 3 + 5
// 16, присваение выполнилось в конце.  
```  
## Инкремент и Декремент  
- Инкремент (++) увеличивает переменную на единицу
- Декремент (--) уменьшает переменную на единицу.

```javascript
let counter = 2
counter++
alert(counter) // 3 
// Инкремент и декремент можно использовать только к переменной!!!!  
```
Так же есть 2 формы 
- префиксная ++counter
- Постфиксная counter++

Обе они делают одинаковые действия, однако разница есть в порядке.
```javascript
//Все операторы возвращают значение, Префиксная форма возвращает новое значение, Постфиксная - старое(до увилечения/уменьшения)
let counter = 1;
let a = ++counter; // префиксная форма увеличила counter на 1 и вернет двойку.(к переменной a присвоилась единица).

let coгnter  = 1; 
let a = counter++; // к переменной a присвоется значение 1, однако действие произошло просто вернулось старое значение до прибавления единицы.

// У инкремента и декремента приоритетность выше чем у умножения и деления
let counter = 1;
alert( 2 * counter++ ); // вернет 2 ибо изначально совершился инкремент и вернул старое значение 1 а позже умножение.
``` 
## Побитовые операторы   
Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.   

Поддерживаются следующие побитовые операторы:  

- AND(и) ( & )
- OR(или) ( | )
- XOR(побитовое исключающее или) ( ^ )
- NOT(не) ( ~ )
- LEFT SHIFT(левый сдвиг) ( << )
- RIGHT SHIFT(правый сдвиг) ( >> )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> );
## Оператор запятая (,)

Применяется очень редко, позволяет вычислять несколько выражений разделяя их запятой.  
Запятая имеет самый низкий приоритет.   

```javascript
let a = (2 + 2, 3 + 4);

alert( a ); // 7 
// первая часть выражения выполнилась, однако вернулась только вторая часть выражения
// По скольку запятая имеет самый низкий приоритет, с ней надо испоьзовать скобки, без них изначально выполнится бинарный плюс, просуммировав a = 4, 7 , затем оператор присваивания, присвоит в a = 4, а все что идет дальше будет игнорированно
// понятным языком:
// оператор присваения имеет приоритет выше чем запятая, а значит оператор присвоит четыре, а запятая так и останется бесхозно стоятью
//обворачивая это в скобки мы даем запятой выполнится перед присваеванием.
```  
Зачем нужна запятая на практике:
```javascript
// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
};
```
**По итогу**, в js есть операторы:
- Унарные
- Бинарные
- Математические
- Инкремент/декремент имеющие 2 формы написания.
- Запятая  
# Операторы сравнения  
- больше/меньше a > b, a < b;
- больше/меньше либо равно a >= b, a <= b;  
- Равно a == b; 
- Не равно a != b;

## Результат сравнения  

```javascript
alert( 2 > 1); // вернет true.
alert( 2 == 1) // вернет false
alert(2 != 1) // вернет true
// в логических оператарах есть лишь два значения true и false
let result = 5 > 4 // результат сравнения присваевается переменной.
alert(result) // true
```
## Сравнение строк
```javascript
alert(`Я` > `А`)  // true
alert(`Коты` > `Кода`) // true
alert(`Сонный` > `Сон`) // true
//Чтобы определить какая строка болше js использует алфавитный или лексикографический порядок
```
**Алгоритм сравнения** 
1. Сравниваются первые символы строк
2. Если первый символ первой строки больше(меньше) второй то первая строка больше(меньше) второй.
3. Если первые символы равны таким же образом сравниваются след символы строк
4. Сравнение идет пока не закончится одна из строк
5. Если обе строки заканчиваются одновременно они равны, либо большей считается более длиная строка

Больше означает что быква в алфавите идет позже.  
Но в js используется юникод, то есть **строчная буква будет больше заглавной**  
## Cравнение разных типов  
При сравнении разных типов js приводит обоих к числу
```javascript
alert('2' > 1); // true
alert('01' == 1) // true строка 01 стала числом 1
```
True и false применяют числа в свое значение
```javascript
alert( true == 1 ); // true
alert( false == 0 ); // true
```  
<details><summary>Интересный вывод</summary>  

```javascript
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
// 1. 0 является булевым значеним и в 0 присвоено значение false
// 2. строка ноль является не пустой а заполненной поэтому вернет true
// 3. в сравнении оператор сводит все значения в числовой формат и получается что ноль равно нулю и это true
```  

</details>  

## Строгое сравнение  
===
```javascript
alert( 0 == false); // true
alert(`` == false); // true
// не забывать что так происходит из за того что оператор == преобразовывает все операнды к числу, то есть false и строку к нулю.
// оператор === проверяет равенство без приведения к типу.
alert( 0 === false); // false т.к. разные типы.
// так же есть оператор строгого неравенства !===
```
## Сравнение с null и undefined  
```javascript
alert( null === undefined) //false тк различны типы
alert(null == undefined) // true Равны друг другу и не равны никаким другим значениям
// при использовании других мат. операторов и операторов сравнения.
// null преобразовывается в нуль
// undefined в NaN
```
**Механика работы операторов, нуля и типа null**  
```javascript
alert(null > 0); // false
alert(null == 0); //false
alert(null >= 0); // true
// в первом случае null преобразовалось в нуль и нуль не больше нуля.
//во втором случае дествует правило равенства null и undefined
// в третьем случае null преобразовался в нуль и нуль действительно больше либо РАВЕН нулю
//В общем всему виной механика работы операторов
```
**Несравнимое значение undefined**  
```javascript
alert(undefined > 0);// false
alert(undefined < 0); // false
alert(undefined == 0); //false
```
На такое поведение есть 2 причины
- Undefined преобразовывается в NaN, а NaN вернет false в любых сравнениях
- Равенство в третьем случае false ибо undefined может быть равен только null либо другому undefined.
## Как избежать проблем
Если придерживаться двух правил можно избежать большую часть несостыковок в коде.  
- Осторожно относится ко всем сравнения c null и undefined только если это не строгое равенство
- Не использовать сравнения `< > <= >=`  с переменными которые могут принимать null либо undefined. Если переменная может их принимать, лучше сделать доп проверку.   

**Итого** 
- Операторы сравнения возврашают лишь 2 значения
- Строки сравниваются посимвольно
- Значения приводятся к числовому типу
- Строгое равно игнорирует приведение к одному типу
- значения null и undefined могут быть равны друг другу и больше никакому значению  

# Условное ветвление if, '?'  
## Инструкция if
Инструкция if(...) выполняет код в скобках и если возвращает true, то выполняет блок кода.
```javascript
let year = propmpt(' вкаком году была спецификация ECMAscript5?', '');
if( year == "2015") alert(`you are right!`);
//стандартный способ написания
if(year == "2015"){
   alert(`you are right!`);
   alert(`you are so clever!`);
};   
```
## Преобразование к логическому типу  
Нужно помнить что
- 0, "", null,undefined,NaN вернут false
- остальное вернет true

Изходя из этого:
```javascript
if (0) {
  //false код не выполнится
}  
if (1) {
   // true код выполнится всегда
}
// передаем зараннее вычисленное значение в if 
let year = 2015
let condition = (year == 2015); // condition преобразуется в true
if(condition) {
   // true 
}  
```
## Блок else
вариант выполнения при других исходах
```javascript
let year = propmpt(' вкаком году была спецификация ECMAscript5?', '');
if(year == 2015) {
   alert(`чел Умен`)
}else {
   alert(`чел не умен`)
}
// несколько условий else if 
if( year < 2015) {
   alert(`маловато`)
}else if(year > 2015){
   alert(`многовато`);
}else{
   alert(`А теперь в самый раз`);
}
// присутствие блока else является необязательным
```  
## Условный оператор '?'  
Нужно определить переменную в зависимости от условия
```javascript
let accessAllowed;
let age = prompt(`Сколько вам лет?`, '');

if (age > 18) {
   accessAllowed = true;
} else {
   accessAllowd = false;
}
alert(accessAllowed);
// Оперетор вопросительный знак(Тернарный) поможет сделать тоже самое быстрее
let result = conditions ? valueOne : valueTwo;
//вычисляется условие, если оно истинно то значение 1, если нет то второе соответственно
let accessAllowed = (age > 18) ? true : false;
// на самом деле нет необходимости заключать условие в скобки так как тернарный оператор имеет почти самый низкий приоритет.

// Несколько тернарных операторов
let age = prompt(`Возраст?`, 18);

let message = (age < 3) ? `Здравствуй малыш!` :
   (age < 18) ? `Привет!` :
   (age < 100) ? `Здравствуйте!` :  
   `Какой необычный возраст`;

alert(message);
//Разьяснение
// Первый вопрос проверяет меньше ли трех переменная age, если да то позвращает сообщение и заканчивает проверку
// второй вопрос на 18
// третий вопрос на 100
// в случае если под последнее значение не подошла переменная выводится всторое значение последнего вопроса.
```
Подводя итоги нужно отметить что тернарный оператор ? нажно использовать лишь в небольших блоках кода с целью сохранения его читабельности.  

**Итого**
- существуют 2 вида условных ветвлений if и ?
- оба они работают одинаково, единственное различи в том что через ? все писать быстрее, однако теряется читабельность кода
- Записывая условие нужно помнить про правила перевода типов операторами
  
# Логические операторы
В js есть 3 логических оператора ||(ИЛИ) &&(И) !(НЕ)  
И у каждого своя механика работы
## || (ИЛИ)
```javascript
result = a || b;
// ИЛИ предназначен для манипулирования только булевыми значениями, если есть хоть один true он вернет true в другом случае false  

alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false  

if (1 || 0) { // работает как if( true || false )
  alert( 'truthy!' );
} // выведет сообщение так 1 это true
// --------------------------------------------------------------
let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'Офис закрыт.' );
}
// в первом сравнении вернет true и на этом проверка закончится, выведется сообщение
// можно передать и больше условаий
let hour = 12;
let isWeekend = true;

if(hour < 10 || hour > 18 || isWeekend){
   alert(`Закрыто`)
}
// вернулась истина на последнем выражении.

// сокращенное вычисление
let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется код просто не дошел до этого момента
// если все операнды являются ложью, вернется последний операнд
```
## &&(И)  
```javascript
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
// работает так же как и ИЛИ только ищет ложь
// возвращает true если оба аргумента true либо false если хоть один аргумент является ложью

let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert( 'The time is 12:30' );
}// амперсанд вернет true тк оба аргумента являюются правдой
// так же как и ИЛИ как только амперсанд находит ложное значение проверка останавливается и воозвращается false.
// а если все операнды являются истинной вернется последний операнд
alert( 1 && 5 ); // 5
```
### **Приоритет у опреатора && выше чем у ||**  
А значит первым выполнится выражение с амперсандом  
```javascript
// иногда при помощи таких операторов можно заменить if
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
// первое выражение вернуло true, проверка продолжается и вычисляется последнее выражение возвращается true и выводится последний операнд.
```  
## !(НЕ)
Оператор принимает один аргумент и выполняет следущие действия
1. Приводит аргумент к логическому типу true/false
2. Возвращает противоположное значение
   
```javascript
alert( !true ); // false
alert( !0 ); // true
//двойное не используется для приобразования в булевый тип
alert(!!"non-empty string"); // true
alert(!!null); // false
// итого обычное не переводит в булевый тип а так же меняет булевое значение на обратное
// двойное не по факту просто делает перевод в булевый тип
```
**Итого**
Существует 3 логических оператора
- || (ИЛИ)
- && (И)
- !(НЕ)

# Оператор обьединения с null "??"
Значение определено если оно отличается от null или undefined
```javascript
a ?? b
a если значение a определено
b если знчение a не определено
// то есть оператор ?? возвращает первый аргумент если он определен и не является null, иначе второй аргумент.
// все тоже самое можно записать в след форме
result = (a !=== undefined && a !=== null) ? a : b;
// как правило такой оператор используют чтобы задать значение потенциально неизвестной переменной
let user;// юзер не определен так что вывод будет на аноним
alert(user ?? `Аноним`);
let user = `Isac`;
alert(user ?? `Anonim`)// Isac переменная была определена

let firstName = null;
let lastName = null;
let nickName = `Supertechno`;
alert(firstName ?? lastName ?? nickName ?? `Anonim`); // Supertechno , выведется первая определенная переменная
// по факту механика очень схожа с оператором ИЛИ, но различие заклюячается в том что
// || ВОЗВРАЩАЕТ ПЕРВОЕ ИСТИННОЕ ЗНАЧЕНИЕ
// ?? ВОЗВРАЩАЕТ ПЕРВОЕ ОПРЕДЕЛЕННОЕ ЗНАЧЕНИЕ.
// || не различиает null indefined false пустаю строку и 0 для него это все false
// а ?? зациклене именно на undefined/null
let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0   
```
## Приоритет  
?? имеет приоритет 4 то есть раньше чем =, ?, но позже практически всех других действий.
```javascript

let height = null;
let width = null;

// важно: используйте круглые скобки
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
```
Так же javascript запрещает использование ?? вместе с другими логическими операторами
```javascript
let x = 1 && 2 ?? 3; // Синтаксическая ошибка

let x = (1 && 2) ?? 3; // Работает без ошибок
alert(x); // 2
// Используй скобки чтобы избежать таких ошибок
```
**Итого**
- Оператор ?? это быстры способ выбрать определенное значение из списка
- имеет очень низкий приоритет
- нельзя использовать вместе с амперсандом и ИЛИ.  
  
# Циклы for и while  
Цикл это функция переберающая значения.
## Цикл while  
```javascript
while(condition){
   ...
};
// пока будет выполнятся условие, цикл будет выполнятся
let i = 0;// задаем переменную равную нулю
while (i < 3){// пока i будет меньше трех тело цикла будет выполнятся
   alert(i); // выводим каждый раз перебранное число
   i++; //заставляем каждый раз число увеличиватся
};
//любое выражение либо переменная могут быть условиями цикла
let i = 3
while (i) {// когда i надекрементируетс до нуля условие станет ложью и выполнение цикла остановится
   alert(i);
   i--;
};
// цикл из одной строки
let i = 3;
while (i) alert(i--);
```
## Цикл do...while
```javascript
do{
   //body of cycle
}while(condition);
//цикл изначально выполняет тело а позже проверяет условие
let i = 0;
do{
   alert(i);
   i++;
}while(i < 3);
// такой цикл нужен если стоит задача того чтобы цикл выполнился хотя бы один раз
```
## Цикл for
```javascript
for(start;condition;step){
   body of cycle;
};
for(let i = 0; i < 3; i++){// 1 задаем переменную(начало), 2 ставим условие как в while, 3 задаем шаг.
   alert(i);
};
// алгоритм работы цикла
// Выполнить начало →
//→ если условие == true, выполнить тело а затем выполнить шаг →
//→ если условие == true, выполнить тело а затем выполнить шаг...

// переменная обьявляемая в блоке цикла известна только блоку цикла!
```
## Пропуск частей цикла
```javascript
let i = 0;
for(;i < 3;){
   alert(i++);
};
// работает аналогично while
//если убрать все из цикла он навечно замкнется
for(;;){
   //forever
};
```
## Прерывание частей цикла break
```javascript
let sum = 0;
while (true) {// пока будет ввод числа цикл будет работать
   let value = +prompt(`push the number`, ``);

   if (!value) break;// если введено что то помимо переменной цикл прерывается
   sum += value; // данные из value передаются в другую переменную
};
alert(`Сумма` + sum);// и выводятся 
```
## Continue
```javascript
// в отличии от break при выполнении цикл не обывается а переходит к следующему шагу
for (let i = 0; i < 10; i++){
   // если остаток от деления числа на 2 равен нулю(четное число) цикл как бы остановится уберет шаг с таким числом и перейдет к следующему
   if( i % 2 === 0) continue;

   alert(i)// 1 , 4 5 7 9.
};
// директива continue позволяет избежать вложенности if в цикле
// нельзя использовать break/continue справа от тернарного оператора.
```
## Метки для break/continue

```javascript
// каждый раз будут выводится координаты от 0,0 до 2,2 пока пользовательне одобрит
for (let i = 0; i < 3; i++){

   for(let j = 0; j < 3; j++) {
      
      let input = prompt(`Значение координат (${i},${j})`, '');

      //если мы захотим перейти к готово сразу отсюда то внешний цикл будет продолжать работу
   };

};
alert(`Ready!`);
// такой цикл нужно как то остановить если пользователь отменил ввод
// Метка
labelName: for (...) {
   ...
}
// перепишем с использованием метки
outer: for (let i = 0; i < 3; i++){

   for(let j = 0; j < 3; j++) {
      
      let input = prompt(`Значение координат (${i},${j})`, '');

      //если пустая строка либо отмена надо выйти из обоих циклов
      if(!input) break outer;
      // означает что разрыв цикла будет до метки outer выше
   };

};
alert(`Ready!`);
// ВАЖНО нельзя прыгнуть в любое место цикла, метка может стоять только выше ее вызова.
```
**Итого**
Существуют циклы
- while(){}
- do{}...while()
- for(start;conditions;step){};
- в циклах for есть директивы break останавливает цикл, continue перепрыгивает
- в циклах for есть метки.  
  
# Коснтрукция switch
Заменяет собой сразу несколько if
```javascript
// как пишется
switch(x){
   case `value1`: // if x === value 1 , ... , break
      ...
      [break]
   case `value2` // if x === value2, ... , brak
   ...
   [break]
   default:
      ...
      [break]
}

let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
    break;
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}
// сработает 4 вариант, проверка остановится, на ближайшем break
// если break нет то выполнение пойдет по ближайшим case
switch (a) {
  case 3:
    alert( 'Маловато' );
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
  default:
    alert( "Нет таких значений" );
}
// выведутся последние три алерта

// любое выражение может быть аргументом для switch и case 
let a = `1`
let b = 0

switch (+a) {
   case b + 1:
      alert(`выполнится ибо 1 переведнное в число тоже что и 0+1`);
      break;

   default:
      alert(`не выполнится`)
}
```
## Группировка case
```javascript
let a = 2 + 2;

switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}
// варианы 3 и 5 выведутся подряд друг за другом, неважно с начало был case 3 или case 5
```
## Разные типы данных

```javascript
let arg = prompt("Введите число?");
switch (arg) {
  case '0':
  case '1':
    alert( 'Один или ноль' );
    break;

  case '2':
    alert( 'Два' );
    break;

  case 3:
    alert( 'Никогда не выполнится!' );
    break;
  default:
    alert( 'Неизвестное значение' );
}
// первые два случая выполнятся так как в arg получается строка и в case
// указаны тоже строки.
// третий вариант не выполнится тк так число.
```  


