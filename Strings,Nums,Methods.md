# Методы у примитивов
## Примитив
+ Это значение примитивного типа
+ Есть таких 7 number string boolean bigInt undefined null symbol.
  
Обьект
+ Может хранить множество значений как свойства
+ Обьявляется при помощи скобок {},( функции тоже являются обьектами).
  
Одна из лучших особенностей обьекта это хранение функции как одного из свойств обьекта
```javascript
let roma = {
  name: Roma,
  sayHi: function() {
    alert('Hello, friend!')
  } 
};
roma.sayHi(); // Hello, friend!
// создан обьект с методом sayHi()
```
Существует множество встроенных обьектов, однако у таких есть обратная сторона - они нуждаются в большей памяти для поддержания внутренней структуры.
## Примитив как обьект
Каждый примитив имеет свой собственный обьект обертку которые называются string, boolean, number, Symbol. Таким образом они имееют разный набор методов.
Алгоритм дествий 
```javascript
let str = 'Hello';
alert(str.toUpperCase);
```
1. строка str примитив в момент обращения к его свойству создает обьект который имеет значение строки и метод toUpperCase().
2. Этот метод запускается и возвращает новую строку.
3. Спец. обьект удаляется оставляя после себя только примитив.
   
В итоге примитивы могут применять методы как обьекты оставаясь такими же легкими и быстрыми.  
**Null и undefined не имеют методов**
# Числа
Числа в js бывают 2 видов
+ обычные числа в js или числа с плавующей точкой двойной точности(обычные числа)
+ BigInt дает возможность работать с числами любой длины.

## Способы записи числа
```javascript
let billion = 1000000000;
// такие числа чтобы не ошибится можно записать проще
billion = 1e9//буква e заменяет нужное количесвто нулей e9 - 9 нулей
alert(7.3e9) // 7.3 миллиарда

// другими словами e умножает число на 1+указанное количество нулей
// 1e3 / 1 *1000
// 1.23e6 / 1.23 * 1000000
// с помощью такой фишки можно записывать и маленькие числа к пример 1 микросекунда
let ms = 0.000001;
ms = 1e-6 // шесть нулей слева от 1
// другими словами тут e подразуменвет деление на 1 + кол во нулей
//1e-3 / 1/1000
// 1.23e - 6/ 1.23/1000000
```
## Шестнадцатиричные, двоичные и восьмиричные числа
### шестнадцатиричные 
Используются для цветов, кодировкии симвлов и т.д.
```javascript
alert( 0xff ) //255
```
Двоичные и восьмиричные используются редко но нужно знать что они есть
```javascript
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмиричная запись числа 255
alert(a == b) // true;
```
Для других систем исчисления рекомендуется использовать ParseInt
## toString(base)
Превращает строковое представление числа в системе исчисления base.
```javascript
let num = 255
alert( num.toString(16)) // ff 16ричная
alert( num.toString(2)) // 11111111  2ичная
// base варьируется от 2 до 36 ( стндратня 10 (десятичная))
```
## Округление
Math.floor - округляет в меньшую сторону 3.1 === 3, -1.1 === -2  
Math.ceil - округляет к бльшему 3.1 === 4, -1.1 === -1.  
Math.round - округление к ближайшему целому(обычное) 3.1 === 3, 3.6 === 4,      -1.1 === -1.    
Math.trunc - удаляет дробную часть без округлений 3.1 === 3 -1.-1 === -1.  
**Если нужно оставить определенное количество дробных**  
```javascript
let num = 1.23456
alert(Math.floor(num * 100) / 100); // 123.456 - 123 - 1.23
```
### toFixed(n)
```javascript
let num = 12.34
console.log(num.toFixed(1)) // '12.3'
num = 12.36
console.log(num.toFixed(1)) // '12.4'
//                               ВАЖНО!!!!!!!!!!!!!!!!!!!!!!
//  toFixed - возвращает строку!!!!!!
// то есть для числа нужно
console.loh(+num.tofixed(1))
```  
## Неточные вычисления
Наиболее часто встречающаяся ошгибка это потеря точности
```javascript
console.log(0.1 + 0.2 === 0.3) // false
console.log(0.1 + 0.2) // 0.30000000000000004
```
**Почему это происходит?**  
число хранится в памяти в бинарной форме как последовательность нулей и единиц, но дроби 0.1 0.2 которые выглядят просто на самом деле являются бесконечной дробью в двоичной форме.    
Другими словами 0.1 это 1/10. в десятичной системе такие числа легко представимы, по сравнению с 1/3 которая бесконечная дробь 0.333333.  
Деление на 10 гарантированно хорошо работает в десятичной системе исчисления но деление на 3 нет. По той же причине в двоичной системе исчисления деление на 2 работает хорошо а 1/10 становится бесконечной дробью.  
Правила округления помогают рещить эту проблему  
```javascript
alert(0.1.toFixed(20) ) // 0.10000000000000000555
// когда 2 такие числа суммируются суммируются и их неточности

let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```
## Проверка isFinite, isNaN
Эти значения являются числами но не обычными для них отведены отдельные проверки
```javascript
//                      isNaN()
console.log( isNaN(NaN)) // true
console.log( isNaN('str')) // true
// если делать обычную проверку
console.log( NaN === NaN) // false
//                      isFinite()
// преобразует аргумент в число и возвращает true если обычное число, не NaN, infinity, -infinity
console.log( isFinite('15')); // true
console.log( isFinite('str')); // false (NaN)
console.log( isFinite(Infinity)) // false (Infinity)
// Пустая строка интерпритируется как нуль!!!
```
### Специальный метод Object.is
Сравнивает значения примерно как === , однако полезен в 2 особых ситуациях
1. работает с NaN: ``Object.is(NaN, NaN) === true,`` работает как надо
2. Значения 0 и -0 разные ``Object.is(0, -0) === false`` редко используетс но технически это разные значения

в остальном работает так же как ===
## ParseInt и ParseFloat
Работает с размерными и числами в которых есть приписка букв
```javascript
console.log(+'100px') // NaN
console.log(parseInt('100px')) // 100
console.log( parseFloat('12.5em')) // 12.5

console.log(parseInt('12.3')) // 12 только целое 
console.log(parseFloat('12.3.4')) // 12.3 остановка чтения на второй точке
// обе функции вернут NaN если число не удалось прочесть

// второй аргумент
//  Определяет систему исчисления
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
alert( parseInt('2n9c', 36) ); // 123456
```  
# Строки
Любые текстовые данные это строка.  
Кавычки ``,"",''.
```javascript
let list = `Guests:
John
Mary
Peter
`
// еще один плюс обратных кавычек
// однако можно делать многострочную структуру и обычными кавычками
//  НО С ИСПОЛЬЗОВАНИЕМ СПЕЦСИМВОЛОВ
let guestList = "Guests:\n * John\n * Pete\n * Mary"
//  \n означает переход на новую строку

// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";
let str2 = `Hello
World`;
```  
Существует множество других спецсимволов
```javascript
// 佫, редкий китайский иероглиф
alert( "\u{20331}" );
//  все спецсимволы начинаются с обратного слэша(символ экранирования)
// он также используется если необходимо вставить в строку кавычку
alert( 'I\'m the Walrus!' ); // I'm the Walrus!
```  
## Длина строки доступ к символам
Свойство length
```javascript
alert(`My\n`.length) // 3
//доступ
// происходит так же как в массиве
let str = 'hello'

alert(str[0]); // h
alert(str.charAt(0)); // h
// последний символ
alert(str[str.length - 1]) // o
// разница [] с charAt в том что если такого не существует [] выведут undefined а charAt пустую строку
// перебор сртоки
for(let key in str){
  console.log(key); // h e l l o
}
```
## Строки неизменяемы!!!!
Нельзя что то поменять в строке как только она создана такой она и останется
```javascript
let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает

// вместо этого можно занести в новыую переменную новую строку
let str = 'hi'
str = 'h' = str[1]; // замена
console.log(str) // 'hi'
```  
## Методы строк
Изменение регистра
```javascript
console.log('Interface'.toUpperCase); // INTERFACE
console.log('Interface'.toLowerCase); // interface
console.log('Interface'[0].toLowerCase); // i
```
Поиск подстроки
```javascript
str.indexOf(substr, pos);
// ищет значение subsctr начиная с позиции pos и возвращает позицию на которой найдено совпадение иначе -1
let str = 'Widget with id';
console.log(str.indexOf('Widget')) // 0 подстрока найдена на позиции 0
console.log(str.indexOf('widget')) // -1 совпадений нет
console.log(str.indexOf('id')) // 1 первое совпадение в слове w id get
// чтобы найти второе вхождение стоит поменять позицию
console.log(str.indexOf('id', 2)) // 12
// чтобы найти все вхождения стоит использовать цикл

// существует обратный метод str.lastIndexOf(substr, position)
// он работает так же только поиск задом на перед
// проверка в if 
if(str.indexOf('Widget')){ // рбаотать не будет
  return true;
}
// потому что найдена 0 позиция а ноль это false
if(str.indexOf('Widget' != -1)){ // излечит ошибку
  return true;
}
// чтобы еще все сократить можно использовать побитовый оператор не ~
if(~str.indexOf('Widget')){
  return true;
}// получается что число оборачивается в формулу -(n + 1), изходя из этого только если поличтся -1 будет 0 и if не сработает
```  
### includes, startsWith, endsWith
str.includes(substr, pos);
содержит ли строка substr с позиции pos, вернет true либо false
```javascript
console.log('Widget with id'.includes('Widget')) // true

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
// методы startsWith и endsWith проверяют заканчивается ли(начинается) строка определенной подстрокой
console.log('Widget'.startsWith('Wid')) // true
console.log('Widget'.endsWith('get')) // true
```  
### Получение подстроки slice substr substring
str.slice(start [, end]);  
Возвращает часть строки от start не включая end
```javascript
let str = 'stringify'
console.log(str.slice(0, 5)) // strin
console.log(str.slice(0, 1)) // s не включая end
// усли end отсутствует возвращается все символы со start
console.log(str.slice(2)) // ringify
//  отрицательные значения означают вывод с конца строки
console.log(str.slice(0, -1)) //y 


str.subsctring( start [, end])
// работает точно также но в отличии от slice() если аргументы меньше не там где надо он перевернет местами их
console.log(str.substring(2, 6)) // ring
console.log(str.substring(6, 2)) // ring
alert( str.slice(6, 2) ); // "" (пустая строка)
// Отрицательные значения не поддерживает 

str.substr(start [, length])
// возвращает часть строки от старт с длиной length
// ring 4 символа с позиции 2
console.log(str.substr(2, 4))
console.log(str.substr(-4, 2)) // gi 2 символа с позиции -4
```  
## Сравнение строк
Короме того что строчная буква больше заглавной, буквы имеющие диакритические знаки идут не по порядку  
``alert( 'Österreich' > 'Zealand' ); // true``  
чтобы разобраться почему так и что вообще происходит нужно погрузится в UTF код  
str.codePointAt(pos) - позволяет узнать код символа  
``alert( "z".codePointAt(0) ); // 122``  
``alert( "Z".codePointAt(0) ); // 90``  
### Правильное сравнение  
Для правильного сравнения нужно использовать метод str.localeCompare(str2), возвращает число которое показывает какая строка больше в соответствии с правилами языка
+ отрицательное если str меньше str2
+ положительное если str больше str 2
+ 0 если равны

``alert( 'Österreich'.localeCompare('Zealand') ); // -1``
## Нормализация
```javascript
let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)
// лечится такое с поомощью метода normalize()
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

```
# Массивы  
Массивы предназначены для упорядоченного хранения данных
```javascript
// обьявление
let arr = [];
let arr = new Array();
// доступ, данные
let fruits = ['Apple', 'Orange', 'Sliva'];
console.log(fruits[0]); // Apple
console.log(fruits[2]); // Slive
// замена элемента
fruits[2] = 'Grusha'; // ['Apple', 'Orange', 'Grusha']
//добавление
fruits[3] = 'Lemon'; // ['Apple', 'Orange', 'Grusha', 'Lemon']
// длина массива
let fruits = ['Apple', 'Orange', 'Sliva'];
console.log(fruits.length); // 3

//  в массиве можно хранить все что угодно
let arr = ['Apple',{name: 'John'}, true, function() { alert('Hi!') } ];
console.log(arr[1].name) // John
arr[3]()//  Hi!
```
Как и с обьектами массив может закканчиваться висячей запятой
## Методы
arr.push() - добавляет элемент в конец.  
arr.shift() - удаляет элемент в начале сдвигая все так что первый ключ становится нулевым.  
arr.pop() - удаляет последний элемент.  
arr.unshift() - добавляет элемент в начало.  
**Стек** - это очередь добавления и удаления элементов из конца используя методы push и pop
```javascript
// конец массива
// pop
let fruits = ["Яблоко", "Апельсин", "Груша"];
console.log( fruits.pop()); // "Груша"
console.log( fruits ) //"Яблоко", "Апельсин" 
//push
fruits.push("Груша");
console.log(fruits); //"Яблоко", "Апельсин", "Груша"

// начало массива
// shift
let fruits = ["Яблоко", "Апельсин", "Груша"];
console.log(fruits.shift()); // "Яблоко"
console.log(fruits); // Апельсин, Груша
// unshift
fruits.unshift("Яблоко");
console.log(fruits); //"Яблоко", "Апельсин", "Груша"
// можно добовлять сразу несколько элементов
let fruits = ["Яблоко"];
fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");
console.log(fruits); //["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
```  
## Устройство массива
Массив это особый подвид обьектов. Массив шире чем обьект, предназначен для работы с упорядоченными данными и содержит свойство length.  
Но в основе все равно леежит **Обьект**.  
**Массив является обьектом и ведет себя как обьект**.  
К примеру он так же копируется по ссылке.  
Js старается хранить элементы массива в непрерывной области памяти, один за другим.  
Не стоит использовать массив как обычный обьект ибо он утратит свою скорость и эффективность.
```javascript
//  к примеру ни кто не запрещает добавить свойство в массив
let fruits = [];
fruits[99999] = 5; // свойство с индексом
fruits.age = 25; // свойство с произвольным именем
// все это сделать возможно и все вроде и будет работать
//  однако движок js поймет что я пытаюсь работать с массивом как с обьектом и отключит оптимизацию и тогда массив потеряет свои свойства.
```  
Неправильное использование массива
+ Добавление нечислового свойства по типо arr.test = 5;
+ Создание дыр добавление arr[0] а потом arr[100] между ними нет ничего
+ Заполнение массива в обратном порядке  

 Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными!!!!!!!!!!!!  
 ## Эффективность  
 Методы push/pop выполняются бысро shift/unshift медленно.  
 Медленно последние 2 выполняются потому что кроме того что они удаляют ключ они перенумеровывают все остальные эллементы и обновить свойство length.  
 Тоже самое с **unshift** чтобы добавить элемент в начало массива нужно все сдвинуть в право, перенумеровать, добавить ключ и обновить length.  
 ## Перебор элементов  
 ```javascript
// самый старый метод по индексам
let arr = ["Яблоко", "Апельсин", "Груша"];
for(let i = 0; i < arr.length; i++) {
  console.log(arr[i]); 
}
// цикл for of проходит по значениям
for(let fruit of fruits) {
  alert(fruits);
}
// не предоставляет доступ к ключу элемента, только к значению.
// технически можно использовать for in тк массив = обьект (не стоит)
// 1 for in может не разобраться точно ли он имеет дело с массивом и вывести ненужные свойства обьекта
//  2 for in оптимизирован под обьект а не под массивы и будет работать в 10 а то и 100 раз медленнее
 ```  
 Свойство length автоматом обновляется при обновлении массива, если более точно сказать это наибольший индекс элемента + 1.  
Length можно перезаписать!!!
```javascript
let arr = [1, 2, 3, 4, 5]; // length = 5

arr.length = 2 // снизил длину до 2
console.log(arr) // 1, 2
arr.length = 5 // вернул длину
console.log(arr[3]) // undefined 

// А это значит что чтобы очистить массив достаточно написать
arr.length = 0;
```
## обьявление new Array()
```javascript
let arr = new Array(2);
console.log(arr[0]); // undefined
console.log(arr.length); // 2
```  
## Многомерный массив
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
console.log( matrix[1][1]) // 5 
```  
## toString
```javascript
let arr = [1, 2, 3];
console.log( arr ); // 1, 2, 3
console.log( String(arr) === '1, 2, 3') // true
// toString возвращает список элементов разделенных заяпятой.


alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
// массивы не имеют ни Symbol.toPtimitive ни valueOf они реализуют преобразование лишь toString такми образом [] становится пустой строкой, [1] становится '1' [1,2] становитя '1,2'. 
```  
# Методы массивов
## добавление удаление элементов
arr.push()  
arr.pop()  
arr.shift()  
arr.unshift()  
<hr/>  

### splice  
Можно удалить элемент с помощью delete но длина массива все равно будет та же
<details><summary>delete</summary>  

```javascript
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert( arr[1] ); // undefined

// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
```

 </details>  
 
 splice - универсальный нож для массива умеет добовлять удалять и вставлять элементы.
 ```javascript
 arr.splice(index[, deleteCount, elem1.. elemN])  
//  начинает с позиции Index, удаляет deletaCount и вставляет elem на их место, возвращает массив из удаленных улементов
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1)  // с поз 1 удалить 1 элемент
console.log(arr); // ["Я", "JavaScript"]
// удаление и вставка элементов
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

// только вставка элемента
let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2 удалить 0 элементов, вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

// отрицательные индексы ведут отсчет с конца
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5
 ```  
 ### slice

 ```javascript
arr.slice(start, end)
// возвращает новый массив в который копирует элементы начиная со start и до end, могут быть отрицательными тогда отсчтет идет с конца массива

let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
//  При вызове slice без аргументов массив просто весь скопируется
 ```
 ### concat
 Создает новый массив в который копирует данные из других массивов и дополнительные значения.
 ```javascript
arr.concat(arg1..argN)
// принимает любое кол во и любые аргументы которые могут быть как массивами так и примитивами.

let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
// он копирует простые элементы массива если попытаться скопировать к примеру обьект он скопирует 
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  length: 1
};
alert( arr.concat(arrayLike) ); // 1,2,[object Object]
 ```
 <details><summary>Если нужно скопировать обьект</summary>  

ЧТобы это сделать нужно добавить свойство Symbol.isConcatSpreadable и обьект обработается как массив, вставятся числовые свойства.Для того чтобы все работало обязательно должны быть числовые свойства и length
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

 </details>  

## Поиск/Перебор
### ForEach()
Запускает функцию для каждого элемента массива
```javascript
arr.forEach(function(item, index, arr){
  // do smth...
})
// Вызов alert для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
// А этот вдобавок расскажет и о своей позиции в массиве:
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} имеет позицию ${index} в ${array}`);
});
// Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
```
## Поиск
### indexOf/lastIndexOf и includes
```javascript
let arr = [1, 0, false];

console.log( arr.indexOf(0)) // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
console.log(arr.includes(1)) // true
// Внимание методы используют строгое равно и находят именно false а не нуль
// отличие в поиске по NaN
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
```
### find и findIndex
Может помочь в поиске массива обьектов, для нахождения обьекта с определенным условием  
let result = arr.find(function(item, index, array) {  
  // =если  true то возвращается текущий элмент, перебор останавливается
});  
item - очередной элемент  
index - ключ  
array - сам массив  
Пример поисковой функции  
```javascript
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
```
Метод arr.findIndex делает тоже самое но возвращает ключ элемента, и -1 если ничего не найдено.
### filter
Возвращает все элементы удовлетворяющие условия массивом.  
```javascript
arr.filter(function(item, index, array) {
  // true - элемент жобовляется в массив, перебор продолжается
  // вернет пустой массив если ничего не найдено
});


let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```  
## Преобразование массива
### map
Вызывает функцию для каждого элемента массива и возвращает результат выполнения этой функции.
```javascript
arr.map(function(item, index, array){
  // вернет новое значение вместо элемента
});

// преобразование каждого жлемента в его длину
let arr = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
console.log(arr); // 5, 7, 6
```
### sort
Сортирует массив на месте изменяя порядок элементов, возвращает отсортированный массив, но так же и оригинальный массив меняется.
```javascript
let arr = [1, 2, 15];

arr.sort();
console.log(arr) // 1, 15 ,2
// по умолчанию элементы сортируются как строки
// чтобы сделать собственную сортировку нужно представить функцию в качестве аргумента sort()
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
};
// применяю для предыдущего массива

let arr = [ 1, 2, 15 ];

arr.sort(compare);

alert(arr);  // 1, 2, 15
// такую функцию сравнения можно написать гораздо короче ведь по факту нужно любое положительное число чтобы сказать больше и любое отрицательное чтобы сказать меньше
let arr = [ 1, 2, 15 ];
arr.sort (function(a, b){return a - b; });
console.log(arr) // 1, 2, 15
// тперь можно сюда подключить стрелки и все будет еще кароче
arr.sort((a, b) => a - b;);
```
### reverse
Меняет порядок наоборот
```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```
### split и join
arr.split(разделитель) - разбивает строку на массив по заданному разделителю.
```javascript
let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
// У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен.

let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

alert(arr); // Вася, Петя
```
arr.join(glue) - наоборот преобразует массив в строку вставляя между элементами glue
```javascript
let arr = ['Вася', 'Петя', 'Маша'];

let str = arr.join(';'); // объединить массив в строку через ;

alert( str ); // Вася;Петя;Маша
```
### reduce/reduceRight
используются для вычисления единого значения на основе всего массива  
arr.reduce(function(reviousValue, item, index, array) {  
     //...  
},[initial]);
функция применяется по очереди ко всем элементам массива и переносит свой результат на следующий вызов.  
previousValue - результат предыдущего вызова функции, равен initial на первом вызове если он передан.  
При вызове функции результат ее вызова на предыдущем элементе передаётся как первый аргумент. По окончанию он становится результатом reduce.

```javascript
let arr = [1, 2, 3, 4, 5];

let res = arr.reduce((sum, current) => sum + current, 0);
console.log(res) //15
// тут reduce сожил все элементы массива 
// 1reduce берет 0 за sum в первой итерации а за current 1
// 2 в sum присваивает 0 + 1, а в current 2
// последняя итерация в sum присвоено 0 + 1 + 2 + 3 + 4 а в current 5
// делается current + sum и присваевается в res

// если убрать значение initial то есть 0, то получится тот же результат, в первой итерации взялась единица.
```
**Стоит использовать initial всегда если массив пуст**
метод arr.reduceright действует аналогично только проходит по массиву с право на лево.
## Проверка на массив Array.isArray
Оператор typeof не отличит массив[]  от обьекта{} у обиих будет object  
```javascript
Array.isArray(value);
console.log(Array.isArray({})); // false
console.log(Array.isArray([])); // true
```
## Аргумент thisArg  
Используется дополнительно во всех методах кроме sort, применяется редко
```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// thisArg - это необязательный последний аргумент
// Значение параметра thisArg становится this для func.

let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```
