# Методы у примитивов
## Примитив
+ Это значение примитивного типа
+ Есть таких 7 number string boolean bigInt undefined null symbol.
  
Обьект
+ Может хранить множество значений как свойства
+ Обьявляется при помощи скобок {},( функции тоже являются обьектами).
  
Одна из лучших особенностей обьекта это хранение функции как одного из свойств обьекта
```javascript
let roma = {
  name: Roma,
  sayHi: function() {
    alert('Hello, friend!')
  } 
};
roma.sayHi(); // Hello, friend!
// создан обьект с методом sayHi()
```
Существует множество встроенных обьектов, однако у таких есть обратная сторона - они нуждаются в большей памяти для поддержания внутренней структуры.
## Примитив как обьект
Каждый примитив имеет свой собственный обьект обертку которые называются string, boolean, number, Symbol. Таким образом они имееют разный набор методов.
Алгоритм дествий 
```javascript
let str = 'Hello';
alert(str.toUpperCase);
```
1. строка str примитив в момент обращения к его свойству создает обьект который имеет значение строки и метод toUpperCase().
2. Этот метод запускается и возвращает новую строку.
3. Спец. обьект удаляется оставляя после себя только примитив.
   
В итоге примитивы могут применять методы как обьекты оставаясь такими же легкими и быстрыми.  
**Null и undefined не имеют методов**
# Числа
Числа в js бывают 2 видов
+ обычные числа в js или числа с плавующей точкой двойной точности(обычные числа)
+ BigInt дает возможность работать с числами любой длины.

## Способы записи числа
```javascript
let billion = 1000000000;
// такие числа чтобы не ошибится можно записать проще
billion = 1e9//буква e заменяет нужное количесвто нулей e9 - 9 нулей
alert(7.3e9) // 7.3 миллиарда

// другими словами e умножает число на 1+указанное количество нулей
// 1e3 / 1 *1000
// 1.23e6 / 1.23 * 1000000
// с помощью такой фишки можно записывать и маленькие числа к пример 1 микросекунда
let ms = 0.000001;
ms = 1e-6 // шесть нулей слева от 1
// другими словами тут e подразуменвет деление на 1 + кол во нулей
//1e-3 / 1/1000
// 1.23e - 6/ 1.23/1000000
```
## Шестнадцатиричные, двоичные и восьмиричные числа
### шестнадцатиричные 
Используются для цветов, кодировкии симвлов и т.д.
```javascript
alert( 0xff ) //255
```
Двоичные и восьмиричные используются редко но нужно знать что они есть
```javascript
let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмиричная запись числа 255
alert(a == b) // true;
```
Для других систем исчисления рекомендуется использовать ParseInt
## toString(base)
Превращает строковое представление числа в системе исчисления base.
```javascript
let num = 255
alert( num.toString(16)) // ff 16ричная
alert( num.toString(2)) // 11111111  2ичная
// base варьируется от 2 до 36 ( стндратня 10 (десятичная))
```
## Округление
Math.floor - округляет в меньшую сторону 3.1 === 3, -1.1 === -2  
Math.ceil - округляет к бльшему 3.1 === 4, -1.1 === -1.  
Math.round - округление к ближайшему целому(обычное) 3.1 === 3, 3.6 === 4,      -1.1 === -1.    
Math.trunc - удаляет дробную часть без округлений 3.1 === 3 -1.-1 === -1.  
**Если нужно оставить определенное количество дробных**  
```javascript
let num = 1.23456
alert(Math.floor(num * 100) / 100); // 123.456 - 123 - 1.23
```
### toFixed(n)
```javascript
let num = 12.34
console.log(num.toFixed(1)) // '12.3'
num = 12.36
console.log(num.toFixed(1)) // '12.4'
//                               ВАЖНО!!!!!!!!!!!!!!!!!!!!!!
//  toFixed - возвращает строку!!!!!!
// то есть для числа нужно
console.loh(+num.tofixed(1))
```  
## Неточные вычисления
Наиболее часто встречающаяся ошгибка это потеря точности
```javascript
console.log(0.1 + 0.2 === 0.3) // false
console.log(0.1 + 0.2) // 0.30000000000000004
```
**Почему это происходит?**  
число хранится в памяти в бинарной форме как последовательность нулей и единиц, но дроби 0.1 0.2 которые выглядят просто на самом деле являются бесконечной дробью в двоичной форме.    
Другими словами 0.1 это 1/10. в десятичной системе такие числа легко представимы, по сравнению с 1/3 которая бесконечная дробь 0.333333.  
Деление на 10 гарантированно хорошо работает в десятичной системе исчисления но деление на 3 нет. По той же причине в двоичной системе исчисления деление на 2 работает хорошо а 1/10 становится бесконечной дробью.  
Правила округления помогают рещить эту проблему  
```javascript
alert(0.1.toFixed(20) ) // 0.10000000000000000555
// когда 2 такие числа суммируются суммируются и их неточности

let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30
```
## Проверка isFinite, isNaN
Эти значения являются числами но не обычными для них отведены отдельные проверки
```javascript
//                      isNaN()
console.log( isNaN(NaN)) // true
console.log( isNaN('str')) // true
// если делать обычную проверку
console.log( NaN === NaN) // false
//                      isFinite()
// преобразует аргумент в число и возвращает true если обычное число, не NaN, infinity, -infinity
console.log( isFinite('15')); // true
console.log( isFinite('str')); // false (NaN)
console.log( isFinite(Infinity)) // false (Infinity)
// Пустая строка интерпритируется как нуль!!!
```
### Специальный метод Object.is
Сравнивает значения примерно как === , однако полезен в 2 особых ситуациях
1. работает с NaN: ``Object.is(NaN, NaN) === true,`` работает как надо
2. Значения 0 и -0 разные ``Object.is(0, -0) === false`` редко используетс но технически это разные значения

в остальном работает так же как ===
## ParseInt и ParseFloat
Работает с размерными и числами в которых есть приписка букв
```javascript
console.log(+'100px') // NaN
console.log(parseInt('100px')) // 100
console.log( parseFloat('12.5em')) // 12.5

console.log(parseInt('12.3')) // 12 только целое 
console.log(parseFloat('12.3.4')) // 12.3 остановка чтения на второй точке
// обе функции вернут NaN если число не удалось прочесть

// второй аргумент
//  Определяет систему исчисления
alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, без 0x тоже работает
alert( parseInt('2n9c', 36) ); // 123456
```  
# Строки
Любые текстовые данные это строка.  
Кавычки ``,"",''.
```javascript
let list = `Guests:
John
Mary
Peter
`
// еще один плюс обратных кавычек
// однако можно делать многострочную структуру и обычными кавычками
//  НО С ИСПОЛЬЗОВАНИЕМ СПЕЦСИМВОЛОВ
let guestList = "Guests:\n * John\n * Pete\n * Mary"
//  \n означает переход на новую строку

// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";
let str2 = `Hello
World`;
```  
Существует множество других спецсимволов
```javascript
// 佫, редкий китайский иероглиф
alert( "\u{20331}" );
//  все спецсимволы начинаются с обратного слэша(символ экранирования)
// он также используется если необходимо вставить в строку кавычку
alert( 'I\'m the Walrus!' ); // I'm the Walrus!
```  
## Длина строки доступ к символам
Свойство length
```javascript
alert(`My\n`.length) // 3
//доступ
// происходит так же как в массиве
let str = 'hello'

alert(str[0]); // h
alert(str.charAt(0)); // h
// последний символ
alert(str[str.length - 1]) // o
// разница [] с charAt в том что если такого не существует [] выведут undefined а charAt пустую строку
// перебор сртоки
for(let key in str){
  console.log(key); // h e l l o
}
```
## Строки неизменяемы!!!!
Нельзя что то поменять в строке как только она создана такой она и останется
```javascript
let str = 'Hi';

str[0] = 'h'; // ошибка
alert( str[0] ); // не работает

// вместо этого можно занести в новыую переменную новую строку
let str = 'hi'
str = 'h' = str[1]; // замена
console.log(str) // 'hi'
```  
## Методы строк
Изменение регистра
```javascript
console.log('Interface'.toUpperCase); // INTERFACE
console.log('Interface'.toLowerCase); // interface
console.log('Interface'[0].toLowerCase); // i
```
Поиск подстроки
```javascript
str.indexOf(substr, pos);
// ищет значение subsctr начиная с позиции pos и возвращает позицию на которой найдено совпадение иначе -1
let str = 'Widget with id';
console.log(str.indexOf('Widget')) // 0 подстрока найдена на позиции 0
console.log(str.indexOf('widget')) // -1 совпадений нет
console.log(str.indexOf('id')) // 1 первое совпадение в слове w id get
// чтобы найти второе вхождение стоит поменять позицию
console.log(str.indexOf('id', 2)) // 12
// чтобы найти все вхождения стоит использовать цикл

// существует обратный метод str.lastIndexOf(substr, position)
// он работает так же только поиск задом на перед
// проверка в if 
if(str.indexOf('Widget')){ // рбаотать не будет
  return true;
}
// потому что найдена 0 позиция а ноль это false
if(str.indexOf('Widget' != -1)){ // излечит ошибку
  return true;
}
// чтобы еще все сократить можно использовать побитовый оператор не ~
if(~str.indexOf('Widget')){
  return true;
}// получается что число оборачивается в формулу -(n + 1), изходя из этого только если поличтся -1 будет 0 и if не сработает
```  
### includes, startsWith, endsWith
str.includes(substr, pos);
содержит ли строка substr с позиции pos, вернет true либо false
```javascript
console.log('Widget with id'.includes('Widget')) // true

alert( "Midget".includes("id") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
// методы startsWith и endsWith проверяют заканчивается ли(начинается) строка определенной подстрокой
console.log('Widget'.startsWith('Wid')) // true
console.log('Widget'.endsWith('get')) // true
```  
### Получение подстроки slice substr substring
str.slice(start [, end]);  
Возвращает часть строки от start не включая end
```javascript
let str = 'stringify'
console.log(str.slice(0, 5)) // strin
console.log(str.slice(0, 1)) // s не включая end
// усли end отсутствует возвращается все символы со start
console.log(str.slice(2)) // ringify
//  отрицательные значения означают вывод с конца строки
console.log(str.slice(0, -1)) //y 


str.subsctring( start [, end])
// работает точно также но в отличии от slice() если аргументы меньше не там где надо он перевернет местами их
console.log(str.substring(2, 6)) // ring
console.log(str.substring(6, 2)) // ring
alert( str.slice(6, 2) ); // "" (пустая строка)
// Отрицательные значения не поддерживает 

str.substr(start [, length])
// возвращает часть строки от старт с длиной length
// ring 4 символа с позиции 2
console.log(str.substr(2, 4))
console.log(str.substr(-4, 2)) // gi 2 символа с позиции -4
```  
## Сравнение строк
Короме того что строчная буква больше заглавной, буквы имеющие диакритические знаки идут не по порядку  
``alert( 'Österreich' > 'Zealand' ); // true``  
чтобы разобраться почему так и что вообще происходит нужно погрузится в UTF код  
str.codePointAt(pos) - позволяет узнать код символа  
``alert( "z".codePointAt(0) ); // 122``  
``alert( "Z".codePointAt(0) ); // 90``  
### Правильное сравнение  
Для правильного сравнения нужно использовать метод str.localeCompare(str2), возвращает число которое показывает какая строка больше в соответствии с правилами языка
+ отрицательное если str меньше str2
+ положительное если str больше str 2
+ 0 если равны

``alert( 'Österreich'.localeCompare('Zealand') ); // -1``
## Нормализация
```javascript
let s1 = 'S\u0307\u0323'; // Ṩ, S + точка сверху + точка снизу
let s2 = 'S\u0323\u0307'; // Ṩ, S + точка снизу + точка сверху

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false, хотя на вид символы одинаковы (?!)
// лечится такое с поомощью метода normalize()
alert( "S\u0307\u0323".normalize() == "S\u0323\u0307".normalize() ); // true

```
# Массивы  
Массивы предназначены для упорядоченного хранения данных
```javascript
// обьявление
let arr = [];
let arr = new Array();
// доступ, данные
let fruits = ['Apple', 'Orange', 'Sliva'];
console.log(fruits[0]); // Apple
console.log(fruits[2]); // Slive
// замена элемента
fruits[2] = 'Grusha'; // ['Apple', 'Orange', 'Grusha']
//добавление
fruits[3] = 'Lemon'; // ['Apple', 'Orange', 'Grusha', 'Lemon']
// длина массива
let fruits = ['Apple', 'Orange', 'Sliva'];
console.log(fruits.length); // 3

//  в массиве можно хранить все что угодно
let arr = ['Apple',{name: 'John'}, true, function() { alert('Hi!') } ];
console.log(arr[1].name) // John
arr[3]()//  Hi!
```
Как и с обьектами массив может закканчиваться висячей запятой
## Методы
arr.push() - добавляет элемент в конец.  
arr.shift() - удаляет элемент в начале сдвигая все так что первый ключ становится нулевым.  
arr.pop() - удаляет последний элемент.  
arr.unshift() - добавляет элемент в начало.  
**Стек** - это очередь добавления и удаления элементов из конца используя методы push и pop
```javascript
// конец массива
// pop
let fruits = ["Яблоко", "Апельсин", "Груша"];
console.log( fruits.pop()); // "Груша"
console.log( fruits ) //"Яблоко", "Апельсин" 
//push
fruits.push("Груша");
console.log(fruits); //"Яблоко", "Апельсин", "Груша"

// начало массива
// shift
let fruits = ["Яблоко", "Апельсин", "Груша"];
console.log(fruits.shift()); // "Яблоко"
console.log(fruits); // Апельсин, Груша
// unshift
fruits.unshift("Яблоко");
console.log(fruits); //"Яблоко", "Апельсин", "Груша"
// можно добовлять сразу несколько элементов
let fruits = ["Яблоко"];
fruits.push("Апельсин", "Груша");
fruits.unshift("Ананас", "Лимон");
console.log(fruits); //["Ананас", "Лимон", "Яблоко", "Апельсин", "Груша"]
```  
## Устройство массива
Массив это особый подвид обьектов. Массив шире чем обьект, предназначен для работы с упорядоченными данными и содержит свойство length.  
Но в основе все равно леежит **Обьект**.  
**Массив является обьектом и ведет себя как обьект**.  
К примеру он так же копируется по ссылке.  
Js старается хранить элементы массива в непрерывной области памяти, один за другим.  
Не стоит использовать массив как обычный обьект ибо он утратит свою скорость и эффективность.
```javascript
//  к примеру ни кто не запрещает добавить свойство в массив
let fruits = [];
fruits[99999] = 5; // свойство с индексом
fruits.age = 25; // свойство с произвольным именем
// все это сделать возможно и все вроде и будет работать
//  однако движок js поймет что я пытаюсь работать с массивом как с обьектом и отключит оптимизацию и тогда массив потеряет свои свойства.
```  
Неправильное использование массива
+ Добавление нечислового свойства по типо arr.test = 5;
+ Создание дыр добавление arr[0] а потом arr[100] между ними нет ничего
+ Заполнение массива в обратном порядке  

 Массивы тщательно настроены в движках JavaScript для работы с однотипными упорядоченными данными!!!!!!!!!!!!  
 ## Эффективность  
 Методы push/pop выполняются бысро shift/unshift медленно.  
 Медленно последние 2 выполняются потому что кроме того что они удаляют ключ они перенумеровывают все остальные эллементы и обновить свойство length.  
 Тоже самое с **unshift** чтобы добавить элемент в начало массива нужно все сдвинуть в право, перенумеровать, добавить ключ и обновить length.  
 ## Перебор элементов  
 ```javascript
// самый старый метод по индексам
let arr = ["Яблоко", "Апельсин", "Груша"];
for(let i = 0; i < arr.length; i++) {
  console.log(arr[i]); 
}
// цикл for of проходит по значениям
for(let fruit of fruits) {
  alert(fruits);
}
// не предоставляет доступ к ключу элемента, только к значению.
// технически можно использовать for in тк массив = обьект (не стоит)
// 1 for in может не разобраться точно ли он имеет дело с массивом и вывести ненужные свойства обьекта
//  2 for in оптимизирован под обьект а не под массивы и будет работать в 10 а то и 100 раз медленнее
 ```  
 Свойство length автоматом обновляется при обновлении массива, если более точно сказать это наибольший индекс элемента + 1.  
Length можно перезаписать!!!
```javascript
let arr = [1, 2, 3, 4, 5]; // length = 5

arr.length = 2 // снизил длину до 2
console.log(arr) // 1, 2
arr.length = 5 // вернул длину
console.log(arr[3]) // undefined 

// А это значит что чтобы очистить массив достаточно написать
arr.length = 0;
```
## обьявление new Array()
```javascript
let arr = new Array(2);
console.log(arr[0]); // undefined
console.log(arr.length); // 2
```  
## Многомерный массив
```javascript
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
console.log( matrix[1][1]) // 5 
```  
## toString
```javascript
let arr = [1, 2, 3];
console.log( arr ); // 1, 2, 3
console.log( String(arr) === '1, 2, 3') // true
// toString возвращает список элементов разделенных заяпятой.


alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
// массивы не имеют ни Symbol.toPtimitive ни valueOf они реализуют преобразование лишь toString такми образом [] становится пустой строкой, [1] становится '1' [1,2] становитя '1,2'. 
```  
# Методы массивов
## добавление удаление элементов
arr.push()  
arr.pop()  
arr.shift()  
arr.unshift()  
<hr/>  

### splice  
Можно удалить элемент с помощью delete но длина массива все равно будет та же
<details><summary>delete</summary>  

```javascript
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert( arr[1] ); // undefined

// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
```

 </details>  
 
 splice - универсальный нож для массива умеет добовлять удалять и вставлять элементы.
 ```javascript
 arr.splice(index[, deleteCount, elem1.. elemN])  
//  начинает с позиции Index, удаляет deletaCount и вставляет elem на их место, возвращает массив из удаленных улементов
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1)  // с поз 1 удалить 1 элемент
console.log(arr); // ["Я", "JavaScript"]
// удаление и вставка элементов
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

// только вставка элемента
let arr = ["Я", "изучаю", "JavaScript"];

// с позиции 2 удалить 0 элементов, вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");

alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

// отрицательные индексы ведут отсчет с конца
let arr = [1, 2, 5];
arr.splice(-1, 0, 3, 4);
alert( arr ); // 1,2,3,4,5
 ```  
 ### slice

 ```javascript
arr.slice(start, end)
// возвращает новый массив в который копирует элементы начиная со start и до end, могут быть отрицательными тогда отсчтет идет с конца массива

let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)

alert( arr.slice(-2) ); // s,t (копирует с -2 до конца)
//  При вызове slice без аргументов массив просто весь скопируется
 ```
 ### concat
 Создает новый массив в который копирует данные из других массивов и дополнительные значения.
 ```javascript
arr.concat(arg1..argN)
// принимает любое кол во и любые аргументы которые могут быть как массивами так и примитивами.

let arr = [1, 2];

// создать массив из: arr и [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// создать массив из: arr и [3,4] и [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
// он копирует простые элементы массива если попытаться скопировать к примеру обьект он скопирует 
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  length: 1
};
alert( arr.concat(arrayLike) ); // 1,2,[object Object]
 ```
 <details><summary>Если нужно скопировать обьект</summary>  

ЧТобы это сделать нужно добавить свойство Symbol.isConcatSpreadable и обьект обработается как массив, вставятся числовые свойства.Для того чтобы все работало обязательно должны быть числовые свойства и length
```javascript
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

 </details>  

## Поиск/Перебор
### ForEach()
Запускает функцию для каждого элемента массива
```javascript
arr.forEach(function(item, index, arr){
  // do smth...
})
// Вызов alert для каждого элемента
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
// А этот вдобавок расскажет и о своей позиции в массиве:
["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} имеет позицию ${index} в ${array}`);
});
// Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
```
## Поиск
### indexOf/lastIndexOf и includes
```javascript
let arr = [1, 0, false];

console.log( arr.indexOf(0)) // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1
console.log(arr.includes(1)) // true
// Внимание методы используют строгое равно и находят именно false а не нуль
// отличие в поиске по NaN
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (должен быть 0, но === проверка на равенство не работает для NaN)
alert( arr.includes(NaN) );// true (верно)
```
### find и findIndex
Может помочь в поиске массива обьектов, для нахождения обьекта с определенным условием  
let result = arr.find(function(item, index, array) {  
  // =если  true то возвращается текущий элмент, перебор останавливается
});  
item - очередной элемент  
index - ключ  
array - сам массив  
Пример поисковой функции  
```javascript
let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Вася
```
Метод arr.findIndex делает тоже самое но возвращает ключ элемента, и -1 если ничего не найдено.
### filter
Возвращает все элементы удовлетворяющие условия массивом.  
```javascript
arr.filter(function(item, index, array) {
  // true - элемент жобовляется в массив, перебор продолжается
  // вернет пустой массив если ничего не найдено
});


let users = [
  {id: 1, name: "Вася"},
  {id: 2, name: "Петя"},
  {id: 3, name: "Маша"}
];

// возвращает массив, состоящий из двух первых пользователей
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
```  
## Преобразование массива
### map
Вызывает функцию для каждого элемента массива и возвращает результат выполнения этой функции.
```javascript
arr.map(function(item, index, array){
  // вернет новое значение вместо элемента
});

// преобразование каждого жлемента в его длину
let arr = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
console.log(arr); // 5, 7, 6
```
### sort
Сортирует массив на месте изменяя порядок элементов, возвращает отсортированный массив, но так же и оригинальный массив меняется.
```javascript
let arr = [1, 2, 15];

arr.sort();
console.log(arr) // 1, 15 ,2
// по умолчанию элементы сортируются как строки
// чтобы сделать собственную сортировку нужно представить функцию в качестве аргумента sort()
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
};
// применяю для предыдущего массива

let arr = [ 1, 2, 15 ];

arr.sort(compare);

alert(arr);  // 1, 2, 15
// такую функцию сравнения можно написать гораздо короче ведь по факту нужно любое положительное число чтобы сказать больше и любое отрицательное чтобы сказать меньше
let arr = [ 1, 2, 15 ];
arr.sort (function(a, b){return a - b; });
console.log(arr) // 1, 2, 15
// тперь можно сюда подключить стрелки и все будет еще кароче
arr.sort((a, b) => a - b;);
```
### reverse
Меняет порядок наоборот
```javascript
let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
```
### split и join
arr.split(разделитель) - разбивает строку на массив по заданному разделителю.
```javascript
let names = 'Вася, Петя, Маша';

let arr = names.split(', ');

for (let name of arr) {
  alert( `Сообщение получат: ${name}.` ); // Сообщение получат: Вася (и другие имена)
}
// У метода split есть необязательный второй числовой аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано, то остаток массива будет отброшен.

let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);

alert(arr); // Вася, Петя
```
arr.join(glue) - наоборот преобразует массив в строку вставляя между элементами glue
```javascript
let arr = ['Вася', 'Петя', 'Маша'];

let str = arr.join(';'); // объединить массив в строку через ;

alert( str ); // Вася;Петя;Маша
```
### reduce/reduceRight
используются для вычисления единого значения на основе всего массива  
arr.reduce(function(reviousValue, item, index, array) {  
     //...  
},[initial]);
функция применяется по очереди ко всем элементам массива и переносит свой результат на следующий вызов.  
previousValue - результат предыдущего вызова функции, равен initial на первом вызове если он передан.  
При вызове функции результат ее вызова на предыдущем элементе передаётся как первый аргумент. По окончанию он становится результатом reduce.

```javascript
let arr = [1, 2, 3, 4, 5];

let res = arr.reduce((sum, current) => sum + current, 0);
console.log(res) //15
// тут reduce сожил все элементы массива 
// 1reduce берет 0 за sum в первой итерации а за current 1
// 2 в sum присваивает 0 + 1, а в current 2
// последняя итерация в sum присвоено 0 + 1 + 2 + 3 + 4 а в current 5
// делается current + sum и присваевается в res

// если убрать значение initial то есть 0, то получится тот же результат, в первой итерации взялась единица.
```
**Стоит использовать initial всегда если массив пуст**
метод arr.reduceright действует аналогично только проходит по массиву с право на лево.
## Проверка на массив Array.isArray
Оператор typeof не отличит массив[]  от обьекта{} у обиих будет object  
```javascript
Array.isArray(value);
console.log(Array.isArray({})); // false
console.log(Array.isArray([])); // true
```
## Аргумент thisArg  
Используется дополнительно во всех методах кроме sort, применяется редко
```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// thisArg - это необязательный последний аргумент
// Значение параметра thisArg становится this для func.

let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```
# Перебираемые обьекты
это концепция которая позволяет перебрать любой обьект в цикле for of  
## Symbol.iterator
Принцип
```javascript
let range = {
  from: 1,
  to: 5
};
// задача сделать так чтобы for of перебрал числа от 1 до 5
// for (num of range) ... num = 1, 2, 3, 4, 5
// чтобы сделать range итерируемым нужно добавить в обьект метод Symbol.iterator(специальный встроеный Symbol созданный для таких операций)

// 1 когда цикл for of запускается он вызывает этот метод один раз либо выдает ошибку если метод не найден. Этот метод должен вернуть обьект с меотдом next.
// 2 Далее for of работает только с возвращенным обьектом
// 3 когда for of хочет получить след значение, вызывает next()
// 4 результат вызова next() имеет вид {done: Boolean, value: any}, где done=true если цикл завершен, если нет value содержит очередное значение.

let range = {
  from: 1,
  to: 5
};
// 1 for of вызывает функцию
range[Symbol.iterator] = funcion(){
  
  // возвращает обьект итератора
  // 2 далеее for of работает с этим итератором
  return {
    current: this.from,
    last: this.to,

    // 3. next вызывается на каждой итерации цикла for of
    next() {
      // должен вернуть значение в виде обьекта {done :-, value:-}
      if (this.current <= this.last) {
        return {done: false, value: this.current++};
      } else {
        return {done: true}
      }
    }
  };
};

for ( let num of range) {
  console.log(num) // 1 2 3 4 5
}
```
Стоит заметить что у самого range нет метода next, next вызывает symbol.iterator.  
Учитывая это можно вписать все выше свойствами в обьект
```javascript
let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
// так код короче но недостатком такого подхода является то что нельзя будет это использовать в двух парралельных циклах for of
```
## Перебор строки как обьекта
```javascript
for (let char of 'test') {
  console.log(char)  // t e s t
};
// сработает с суррогатными парами

let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, а затем 😂
}
```
### Явный вызов итератора(как все работает под копотом)
```javascript
let str = 'Hello'

let iterator = str[Symbol.iterator]();
while (true) {
  let result = iterator.next();
  if (result.done) break;
  console.log(result.value); // выводит символы один за другим
};
```  
## Итерируемые обьекты и псевдомассивы
Итерируемые обьекты - это обьекты которые реализуют метод Symbol.iterator.  
Псевдомассив - это обьект который выглядит как массив, в нем есть индексы и свойство Length.  
Иногда можно встретить и такие и такие обьекты одновременно.  
К примеру строки они одновременно являются итерируемым обьектом и у них есть свойство length и индексы, а значит они и псевдомассив.  
```javascript
// пример не итерируемого псевдомассива
let arrayLike = { // есть индексы и свойство length => псевдомассив
  0: "Hello",
  1: "World",
  length: 2
};

// Ошибка (отсутствует Symbol.iterator)
for (let item of arrayLike) {}
```
Общее в этих понятиях то что они оба не массивы, для них не работают методы push, pop, и тд.  
**Но что если нужно использовать методы массивов на такой обьект?**
## Array.from  
Принимает итерируемый обьект или псевдомассив и делает из него настоящий массив.
```javascript

let arrayLike = {
  0: 'Hello',
  1: 'World',
  length: 2
};
let arr = Array.from(arrayLike);
console.log(arr.pop())// World, метод сработал, удалил первый1 ключ.
// Array.from проверяет обьект является итерируемым или псевдомассивом а потом копирует его свойства в массив

// полный синтаксис
Array.from(obj, [, mapFn, thisArg]);
// необязательный аргумент может быть функцией которую следует применить к каждому элементу при копировании, thisArg позволяет применить this для этой функции

let range = {
  from: 1,
  to: 5
};
let arr = Array.from(range, num => num * num);
console.log(arr) // 1 4 9 16 25

// использование такого метода для работы с суррогатными парами
let str = '𝒳😂';

// разбивает строку на массив её элементов
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
```  
# Map и Set  
## Map
Это коллекция, ключ/значение как и обьект, но основное отличие в том что map хранит ключи любого типа  
+ new Map() – создаёт коллекцию.
+ map.set(key, value) – записывает по ключу key значение value.
+  map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
+  map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
+  map.delete(key) – удаляет элемент по ключу key.
+  map.clear() – очищает коллекцию от всех элементов.
+  map.size – возвращает текущее количество элементов.  

```javascript
let map = new Map();
map.set('1', 'str1'); // ключ это строка
map.set(1, 'num1'); // ключ это число
map.set(true, 'bool1'); //ключ это булевое значение.
// обычный обьект все ключи ведет к строкам в отличие от map
console.log(map.get(1)); //? 'num1'
console.log(map.get('1')); // 'str1'
console.log(map.size); // 3
```
Map может использовать обьекты в качестве ключей
```javascript
let john = { name: 'John'};
// сохраним кол во посещений пользозвателя
let visitCountMapr = new Map();
// занесение обьекта как ключа для 123 
visitCountMap.set(john, 123);
console.log(visitCountMap.get(john)); 123
```  
Обьект Map сравнивает ключи как === , но одно но в том что **NaN считается равным NaN**.  
map.set можно обьединить в цепочку вызовов  
```javascript
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
```  
### Перебор Map
Для перебора Map существует 3 метода  
+  map.keys() – возвращает итерируемый объект по ключам,
+  map.values() – возвращает итерируемый объект по значениям,
+  map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.

```javascript
let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);
// по ключам 
for (let vegetable of recipeMap.keys()) {
  console.log(vegetable) // огурец помидор лук
};
for (let amount of recipeMap.values()) {
  console.log(values); // 500 350 50
}:
for (let entry of recipeMap.entries()) {
  console.log(entry)  //ключ значение
}
```
В map в отличие от обьектов перебор идет по порядку добавления элементов   
### Object.entries: Map из Object  
при создании Map можно указать массив с парами ключ-значение для инициализации.
```javascript
// массив пар [ключ, значение]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);
alert( map.get('1') ); // str1

// если уже есть обычный обьект и нужно сделать Map из него:
let obj = {
  name: "John",
  age: 30
};
let map = new Map(Object.entries(obj));
```  
### Object.fromEntries: Object из Map  
Получив массив пар ``[ключ:значение]`` создает обьект.  
```javascript
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);
// prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2

// Практическое применение!!!!!!
// нужно передать данные из Map в сторонний код который ожидает обьект.
// вот как это сделать

let obj = Object.fromEntries(map.entries()); // создаём обычный объект (*)
// готово!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```
## Set
Обьект set это особый вид коллекций, множество значений(без ключей) каждое из которых может появлятся лишь один раз.  
Методы:
+  new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
+  set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
+  set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
+  set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
+  set.clear() – удаляет все имеющиеся значения.
+  set.size – возвращает количество элементов в множестве.  

Главная черта set заключается в set.add(), при повторных вызовах ничего не происходит.  
Например ожидаются поситители и необходимо составить из список, но повторные визиты не должны приводить к дубликатам, обьект set идеально подойдет тут.
```javascript
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

console.log(set.size) // 3

for (let user of set) {
  console.log(user.name) // john pete mary
};
// все тоже самое можно реализовать без set с помощью arr.find , но это чудовищные потери производительности.
```  
### Перебор обьекта set 
можно перебрать обьект как с помощью for of так и forEach
```javascript
let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

set.forEach((value, valueAgain, set) => {
  console.log(value);
});
// при переборе идут аргменты значение, тоже самое значение и потом сам обьект, значение появляется дважды.
// сделано такое для совместимости с обьектом Map
```
Set имеет такие же встроеные методы как и Map:  
set.keys, set.values, set.entries.  
# WeakMap и WeakSet  
## WeakMap
Если в Map обьект используется как ключ и мы удалим этот обьект, то он останется в памяти и обьекте map, WeakMap удаляет из себя ключ обьект если он был удален внешне.
 ```javascript
//  первое отличие в том что ключи обязательно обьекты, не примитивы
let weakMap = new weakMap();

 let obj = {};
 weakMap.set(obj, 'ok');
 weakMap.set('test', 'Whoops') // ошибка, test not an object.

//  теперь если используется обьект в качестве ключа и на него больше нет ссылок кроме weakmap, он будет удален и там 

let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!
 ```  
 WeakMap не поддерживает перебор и методы keys(), values(), entries(). Нет способа взять все ключи или значения из нее.  
 Методы WeakMap :
+  weakMap.get(key)
+  weakMap.set(key, value)
+  weakMap.delete(key)
+  weakMap.has(key)

## Где нужно применять, реальные примеры  
В основном, WeakMap используется в качестве дополнительного хранилища данных. 
Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке, и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект, то WeakMap – как раз то, что нужно.
```javascript
weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы" будут автоматически уничтожены
```  
Пример со счетчиком захода для пользователя
```javascript
// 📁 visitsCount.js
let visitsCountMap = new Map(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
//другая часть кода в которой сам пользователь и которая выводит его посещения
// 📁 main.js
let john = { name: "John" };

countUser(john); //ведём подсчёт посещений

// пользователь покинул нас
john = null;

// обьект удален но он останется в памяти из за того что ключ в обьекте map
// во избежании такого нужен WeakMap
// 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // map: пользователь => число визитов

// увеличиваем счётчик
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
```
[ЕЩЕ ПРИМЕР С КЕШИРОВАНИЕМ](https://learn.javascript.ru/weakmap-weakset#primenenie-dlya-keshirovaniya)  

## WeakSet  
Коллекция ведет себя похоже
+ Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
+ Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
+ Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.  

Будучи «слабой» версией оригинальной структуры данных, она тоже служит в качестве дополнительного хранилища. Но не для произвольных данных, а скорее для значений типа «да/нет». Присутствие во множестве WeakSet может что-то сказать нам об объекте.  
К примеру можно использовать ее для добовления пользователей которые посещали сайт
```javascript
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически
```
# Object keys values entries  как изменяющие обьект методы  
Object.keys(obj);  
Вызывая таким образом метод получаю его реасльный массив, дальше можно использовать методы массива а после вернуть обратно в обьектный тип  
```javascript
let user = {
  name: "John",
  age: 30
};

// перебор значений
for (let value of Object.values(user)) {
  alert(value); // John, затем 30
}
```
<details><summary>Object.keys/values/entries игнорируют символьные свойства(Symbol)</summary>  

Если нужно учесть и символы, использовать метод Object.getOwnPropertySymbols, вернет массив лишь символов, либо Reflect.ownKyes(obj) вернет все ключи.

</details>  

## Трансформация обьекта как массива  
Для этого нужно  
1. Вызов Object.entries(obj) возвращает массив пар ключ/значение для obj.  
2. На нем вызвать метод массив.
3. Использовать Object.fromEntries чтобы обратно преобразовать в обьект

```javascript
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};
let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
```
# Деструктурирующее присваивание   
Деструктуризация - это 'распаковка' обьекта в кучу переменных.
## Деструктуризация массива
```javascript
let arr = [1 , 2];
let [one, two] = arr;
console.log(one) // 1
console.log(two) // 2
```  
Теперь вместо ключей данные сложены в переменную  
**ГЛАВНАЯ ЗАДАЧА ДЕСТРУКТУРИЗАЦИИ ЭТО КОПИРОВАНИЕ ДАННЫХ В ПЕРЕМЕННЫЕ**  
```javascript
// можно проспустить переменную используя запятую
let [one, ,two] = [1, 3, 2];
console.log(two) // 2

// можно использовать любой перебираемый обьект не только массив
let [a, b, c] = 'abc';
let [one, two, three, four] = new Set([1, 2, 3, 4]);

// можно использовать все что угодно присваивающие слево
let user = {};
[user.name, user.surname] = "Ilya Kantor".split(' ');

alert(user.name); // Ilya  

// цикл с entries()
let user = {
  name: 'john',
  age: 30
};
for (let [key, value] of Object.entries(user)) {
  console.log(`${key}:${value}`);
}

// для обьекта Map
let user = new Map();
user.set('name', 'john');
user.set('age', '30');
for(let [key, valuie] of user) {
  console.log(`${key}:${value}`);
}
```
## Остаточные параметры ... (вечно непонятное трехточие)
... используется чтобы не только получить первые значения, но и собрать все остальные, добовляется еще один **параметр** ...
```javascript
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];  
console.log(name1); // Julius
console.log(name2); // Caesar
console.log(rest[0]); // Consul
console.log(rest[1]); // of the Roman Republic
// в rest включились все остальные данные
console.log(rest.length) // 2

//   ТАКАЯ ПЕРЕМЕННАЯ С ТОЧКАМИ ДОЛЖНА ОБЯЗАТЕЛЬНО СТОЯТЬ НА ПОСЛЕДНЕМ МЕСТЕ В ДЕСТРУКТУРИРУЮЩЕМ ПРИСВАИВАНИИ
```
### значения по умолчанию
Если значений меньше чем переменных, ошибки не будет
```javascript

let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined

// если нужно указать значения по умолчанию то ихз надо присвоить
let [name = 'Guest', surname = 'Anonymous'] = ['Julious'];
// Значения по умолчанию могут быть сложнее и даже быть функциями к примеру
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
```  
## Деструктуризация обьекта  
так же работает с обьектами ``let {var1, var2} = {var1..., var2...}``
справа готовый обьект с лево переменный слжащие шаблонами для свойств
```javascript
let options = {
  title: 'menu',
  width: 100,
  height: 200
};
let {title, width, height} = options;
console.log(title, width, height); // Menu 100 200
// Свойства options.title, options.width и options.height присваиваются соответствующим переменным  
// можно записать по другому
let {height, width, title} = { title: "Menu", height: 200, width: 100 };

// если нужно присвоить свойство обьекта переменной с другим названием, например свойство options.width присвоить переменной w можно использовать двоеточик
let {width: w, height: h, title} = options
// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200

// так же можно занести свойства по умолчанию 
let options = {
  title: 'Menu'
};
let {width = 100, hieght = 200, title} = options;
// как и с массивами можно ставить и функции и прочее в щначения по умолчанию
let options = {
  title: "Menu"
};
let {width = prompt("width?"), title = prompt("title?")} = options;

// Можно совмещать двоеточие и присваивание
let {width: w = 100, height: h = 200, title} = options;  

// Если имеется большой обьект с множеством свойств, можно взять только то что нужно
let options = {
  title: "Menu",
  width: 100,
  height: 200
};
let {title} = options;
console.log(title) // Menu
```  
## Остаток обьекта ...
Так же как и в массиве
```javascript
let options = {
  title: "Menu",
  width: 100,
  height: 200
};  
let {title, ...rest} = options;
//rest={height: 200, width: 100}
console.log(rest.height) // 200
console.log(rest.width) //100
```
## Вложенная деструктуризация  
О том что обьект содержит вложенные свойства и обьекты, нужно использовать более сложную деструктуризацию
```javascript
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

let {
  size: { // отдельно переменные для size
    width,
    height
  },
  items: [item1, item2], // элементы к item
  title = 'menu' // добовлено значение по умолчанию
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```
## Умные параметры функциё
Бывают функции которые создают много параметров к примеру функция создающая пользовательский интерфейс.Записывать их в следующем виде плохая практика
```javascript
function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
// чтобы сделать эту запись адекватной нужно передать параметры как обьект .
//передача обьекта в функцию
let options = {
  title: 'my Menu',
  items: ['item1', 'item2']
};
function showMenu ({title = 'Untitled', width = 200, height = 100, items = []}) {
  // title, items – взято из options,
  // width, height – используются значения по умолчанию
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}
showMenu(options);
// так как же как и до можно использовать еще более сложное деструктурирование со вложенными обьектами доветочием и присваеванием

let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  
  height: h = 200, // height присваиваем в h
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```
**ВАЖНО**, при использоввании такого подхода функция подразумевает передачу обьекта, если не нужно передавать никаких аргументов стоит передать пустой обьект ``showMenu({}){};``  
Можно это оптимизировать используя пустой обьект значением по умолчанию для обьекта параметров
```javascript
function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}
showMenu(); // Menu 100 200
```  
# Дата и время
Обьект Date содержит дату и время и предстовляет методы управления ими.  
## Создание
```javascript
let now = new Date();// создается с помощью директивы new
console.log(now); // текущие дата и время

new Date(milliseconds):
// Создать объект Date с временем, равным количеству миллисекунд (тысячная доля секунды), прошедших с 1 января 1970 года UTC+0.

let Jan01_1970 = new Date(0)// 0 соответствует 01.01.1970 UTC+0
alert( Jan01_1970 );

// докину 24 часа
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
```
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется таймстап.

Это – легковесное численное представление даты. Из таймстампа всегда можно получить дату с помощью new **Date(timestamp)** и преобразовать существующий объект Date в таймстамп, используя метод **date.getTime()**.  
Можно задавать даты до 1 янв 1970, ставя минус.  
```javascript
// 31 декабря 1969 года
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
```
**new Date(datestring)**  
Если аргумент всего один, и это строка, то из неё «прочитывается» дата.
```javascript
let date = new Date("2017-01-26");
alert(date);
// Время не указано, поэтому оно ставится в полночь по Гринвичу и
// меняется в соответствии с часовым поясом места выполнения кода
// Так что в результате можно получить
// Thu Jan 26 2017 11:00:00 GMT+1100 (восточно-австралийское время)
// или
// Wed Jan 25 2017 16:00:00 GMT-0800 (тихоокеанское время)
```
**new Date(year, month, date, hours, minutes, seconds, ms)**
Создает Date с заданным в местном часовом поясе, обязательны только первые 2 аргумента.
+ year состоит из 4 цифр
+ month 0 - январь, 11 - декабрь
+ date - день месяца, если не задан то 1.
+ Если параметры hours/minutes/seconds/ms отсутствуют, их значением становится 0.  
```javascript
new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, так как часы и проч. равны 0
```
## Получение компонентов даты  
+ **getFullYear()** получить год
+ **getMonth()** месяц
+ **getDate** день
+ **getHours(), getMinutes(), getSeconds(), getMilliseconds()** часы, минуты, секунды или миллисекунды.

Можно получить определенный день недели **getDay()** от 0 - вс до 6 - сб  
Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.

Можно вернуть в каком то определенном поясе используя UTC
```javascript
let date = ew Date();
// час в текущем поясе
console.log(date.getHours());
console.log(date.getUTCHours() );
// час в часовом поясе UTC+0 (лондонское время без перехода на летнее время)
// существует 2 особых миетода без UTC
// getTime() - вернет кол во миллесекунд с 1 янв 1970
// getTimeOffset - вернет разницу в минутах между UTC и местным поясом 
Console.log(new Date().getTimeOffset() );
// если вы в часовом поясе UTC-1, то выводится 60
// если вы в часовом поясе UTC+3, выводится -180
```
## Установка компонентов даты
Следующие методы позволяют установить компоненты даты и времени:

+ setFullYear(year, [month], [date])
+ setMonth(month, [date])
+ setDate(date)
+ setHours(hour, [min], [sec], [ms])
+ setMinutes(min, [sec], [ms])
+ setSeconds(sec, [ms])
+ setMilliseconds(ms)
+ setTime(milliseconds) (устанавливает дату в виде целого количества миллисекунд, прошедших с 01.01.1970 UTC).

У всех этих методов, кроме setTime(), есть UTC-вариант  
Некоторые методы могут устанавливать неск компонентов дат
```javascript
let today = new Date();

today.setHours(0);
alert(today); // выводится сегодняшняя дата, но значение часа будет 0

today.setHours(0, 0, 0, 0);
alert(today); // всё ещё выводится сегодняшняя дата, но время будет ровно 00:00:00.
```
## Автоисправление даты  
Автоисправление означает что можно устанавливать значения вне логичного диапозона.
```javascript
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!

let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);
alert( date ); // 1 Mar 2016

let date = new Date();
date.setSeconds(date.getSeconds() + 70);
alert( date ); // выводит правильную дату
```
## Преобразование к числу, разность дат
```javascript
let date = new Date();
alert(+date); // количество миллисекунд, то же самое, что date.getTime()

let start = new Date(); // начинаем отсчёт времени

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // заканчиваем отсчёт времени

alert( `Цикл отработал за ${end - start} миллисекунд` );
```
## Date.now()  
Использовать если просто нужно измерить время с 1 янв 1970 по сейчас **Это самый быстрый способ получить величину текущего времени на сейчас**  
## Разбор строки с датой  
Date.parse(str) - считывает дату со строки
Формат строки должен быть следующим: YYYY-MM-DDTHH:mm:ss.sssZ, где
+ YYYY-MM-DD – это дата: год-месяц-день.
+ Символ "T" используется в качестве разделителя.
+ HH:mm:ss.sss – время: часы, минуты, секунды и миллисекунды.
+ Необязательная часть 'Z' обозначает часовой пояс в формате +-hh:mm. Если указать просто букву Z, то получим UTC+0.  

Вызов Date.parse(str) обрабатывает строку в заданном формате и возвращает таймстамп (количество миллисекунд с 1 января 1970 года UTC+0). Если формат неправильный, возвращается NaN.  
```javascript
let ms = Date.parse('2012-01-26T13:51:50.417-07:00');

alert(ms); // 1327611110417 (таймстамп)
let date = new Date( Date.parse('2012-01-26T13:51:50.417-07:00') );

alert(date);
```

