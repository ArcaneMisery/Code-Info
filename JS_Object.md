# Обьекты
**Обьект** - используется для хранения коллекций различных значений и более сложных вещей. 
Обьект создается при помощи {} с необязательным списком свойств в них.Свойтво это пара ключ значение ( isObject: True), значением может быть что угодно.
```javascript
let user = new Object(); // создание обьекта при помощи конструктора обьекта
let user = {}// создание обьекта при помощи литерала {} - литерал
// так обьект без свойств и значений в нем является пустым обьектом, но обьектом
let user = {// создаем обьект
   name: `John`,// под ключом name хранится john
   age: 30// под ключом age находится 30
}
// можно сказать что этот обьект как ящик под именем user с папками name и age в ней.
// в обьектах есть свойства подписанные под ключами.
// заметить что чтобы обратится к папке мы должны след образом обьект.папка
alert(user.name);//   john
alert(user.age);// 30
// Добавление нового свойства
user.isAdmin = true;
//заметить что в этом случае используется оператор присваевания
alert(user.isAdmin)//true
//удаление свойства
delete user.age
alert(user.age)// undefined

// имя свойства можно дать несколькими словами тогда синтаксис такой
let user = {
   name: `John`,
   "likes birds": true// имя свойства из нескольких слов должно быть в кавычках
}
// последнее свйство обьекта может закканчиватся запятой или это висячая запятая
let user = {
   name: `wasya`,
}
// оставляя так запятую можно не боятся ошибок при добавлении новых свойств.
```
<details><summary>Обьект который обьвлен через const можно менять</summary>  

```javascript
const user = {
   name: `wasya`
};
user.name = `Petya`
alert(user.name)// Petya
// так происходит из за того что const запрещает менять саму переменную а не ее содержимое 
```
</details>  

## доступ к переменным в несколько слов
```javascript
let user = {};

user["likes birds"] = true; // присваиваем свойство и значение в обьект
alert(user["likes birds"]); // true
delete user["likes birds"]; // удаление свойства

// квадратные скобки позволяют обратится к свойству имя которого результат выражения
// например хранение имени свойства в переменной
let key = "likes birds"
user[key] = true;// тоже самое что и user["likes birds"] = true  
// переменная key может быт вычисленна во время выполнения кода или зависеть от какого либо ввода из вне
let user = {
   name: `John`,
   age: 30,
};

let key = prompt(`Что вы ххотели узнать о нем?`, "name");
//доступ к свойству 
alert( user[key] ) ;// john если введено name 
// значит ли это что описанные свойства являются строчками??????!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//зпись через точку вернет undefined  
```
## Вычисляемые свойства
```javascript
let fruit = prompt(`What fruit do you want?`,`apple`)

let bag = {
   [fruit] = 5,//имя свойства будет взято из переменной fruit
};
alert( bag.apple ) // 5 если введено `apple`
// смысл во всем этом заключается в том что надо взять свойство из переменной которая вычисляется в процессе
// более сложный вариант применения []
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```
## Свойство из переменной
```javascript
function makeUser(name, age) {
   return {
      name: name
      age: age
      // another property
   };
}

let user = makeUser(`John`, 30);
alert(user.name); //john
// мы сделали конструктор юзеров, такая конструкция настолько популярна что существует в на много упрощенных формах
function makeUser(name, age) {
   return {
      name, // Тоже самое что и name: name
      age // тоже самое что и age: age
   };
}
```  
## Имена свойств
Имя переменных не может совпадать с зарезервированными словами такими как for, function, let  и т.д.
Одноко для оьектов такое ограничение отсутствует
```javascript
let obj = {
   for: 1,
   let: 2,
   return: 3
}
alert( obj.for + obj.let + obj.return );  // 6
// нет никаких ограничений к именам свойств
// по дефолту все имена свойств - сроки либо символы(с ними позже)

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
```  
## Проверка существования свойства оператор in
В принципе получить безошибочно доступ к любому несуществующему свойству можно просто такое свойство будет undefined.  
И это будет носить хзарактер проверки
```javascript
let user = {}; // литерал

alert( user.noSuchProperty === undefined ); // true 
// оператор in

`key` in object

let user = {name: `wasya`, age: 30};
alert( `age` in user); // true такой есть
alert(`dfageds` in user); // false user.dfageds не существует
// кавычки означают образение именно по свойству(ибо они строки)
// обращение же без ковычек означает обращение по переменной
let user = { age: 30 };

let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key
```  
На деле оператор in нужен для замены обычной проверки на undefined только в случае если одной из свойств и есть undefined  

```javascript
let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```  
## Цикл for...in
Используется для перебора всех свойств и отличается от for
```javascript
for (key in object){
   ...
   // выполняется для каждого свойства обьекта
}
let user = {
   name: `John`,
   age: 30,
   isAdmin: true
};

for(let key in user) {
   // алертаем ключи
   alert( key );// name age isAdmin
   // алертаем их значения
   alert(user[key]);// john 30 true
};
// такой порядок вывода означает что свойства в обьекте неким образом упорядочены об этом нижу
```
## Упорядолчение свойств обьекта
```javascript
let codes = {
   `49`: `Germany`
   `375`: `Belarus`
   `8`: `Russia`
   //...
   `1`: `USA`
};
for (let code in codes) {
   alert( code ); // 1, 8, 49, 375
};
//номера пойдут по возрастанию ибо являются целыми числами 
// такое еще называется целочисленным свойством 
// целый числа идут от 1 до бесконечности в порядке возрастания всегда
// но если свойства будут не целочисленными то они будут идти в порядке создания
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user) {
  alert( prop ); // name, surname, age
}
// таким образом если мы поставим унарный плюс перед каждым свойством они не будут целочисленными ибо "375" не тоже самое что и "+375"
let codes = {
   `49`: `Germany`
   `375`: `Belarus`
   `8`: `Russia`
   //...
   `1`: `USA`
};
for (let code in codes) {
   alert( +code ); // 49 375 8 1
};
// теперь все работает
```
