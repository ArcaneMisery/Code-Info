# Обьекты
**Обьект** - используется для хранения коллекций различных значений и более сложных вещей. 
Обьект создается при помощи {} с необязательным списком свойств в них.Свойтво это пара ключ значение ( isObject: True), значением может быть что угодно.
```javascript
let user = new Object(); // создание обьекта при помощи конструктора обьекта
let user = {}// создание обьекта при помощи литерала {} - литерал
// так обьект без свойств и значений в нем является пустым обьектом, но обьектом
let user = {// создаем обьект
   name: `John`,// под ключом name хранится john
   age: 30// под ключом age находится 30
}
// можно сказать что этот обьект как ящик под именем user с папками name и age в ней.
// в обьектах есть свойства подписанные под ключами.
// заметить что чтобы обратится к папке мы должны след образом обьект.папка
alert(user.name);//   john
alert(user.age);// 30
// Добавление нового свойства
user.isAdmin = true;
//заметить что в этом случае используется оператор присваевания
alert(user.isAdmin)//true
//удаление свойства
delete user.age
alert(user.age)// undefined

// имя свойства можно дать несколькими словами тогда синтаксис такой
let user = {
   name: `John`,
   "likes birds": true// имя свойства из нескольких слов должно быть в кавычках
}
// последнее свйство обьекта может закканчиватся запятой или это висячая запятая
let user = {
   name: `wasya`,
}
// оставляя так запятую можно не боятся ошибок при добавлении новых свойств.
```
<details><summary>Обьект который обьвлен через const можно менять</summary>  

```javascript
const user = {
   name: `wasya`
};
user.name = `Petya`
alert(user.name)// Petya
// так происходит из за того что const запрещает менять саму переменную а не ее содержимое 
```
</details>  

## доступ к переменным в несколько слов
```javascript
let user = {};

user["likes birds"] = true; // присваиваем свойство и значение в обьект
alert(user["likes birds"]); // true
delete user["likes birds"]; // удаление свойства

// квадратные скобки позволяют обратится к свойству имя которого результат выражения
// например хранение имени свойства в переменной
let key = "likes birds"
user[key] = true;// тоже самое что и user["likes birds"] = true  
// переменная key может быт вычисленна во время выполнения кода или зависеть от какого либо ввода из вне
let user = {
   name: `John`,
   age: 30,
};

let key = prompt(`Что вы ххотели узнать о нем?`, "name");
//доступ к свойству 
alert( user[key] ) ;// john если введено name 
// значит ли это что описанные свойства являются строчками??????!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//зпись через точку вернет undefined  
```
## Вычисляемые свойства
```javascript
let fruit = prompt(`What fruit do you want?`,`apple`)

let bag = {
   [fruit] = 5,//имя свойства будет взято из переменной fruit
};
alert( bag.apple ) // 5 если введено `apple`
// смысл во всем этом заключается в том что надо взять свойство из переменной которая вычисляется в процессе
// более сложный вариант применения []
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```
## Свойство из переменной
```javascript
function makeUser(name, age) {
   return {
      name: name
      age: age
      // another property
   };
}

let user = makeUser(`John`, 30);
alert(user.name); //john
// мы сделали конструктор юзеров, такая конструкция настолько популярна что существует в на много упрощенных формах
function makeUser(name, age) {
   return {
      name, // Тоже самое что и name: name
      age // тоже самое что и age: age
   };
}
```  
## Имена свойств
Имя переменных не может совпадать с зарезервированными словами такими как for, function, let  и т.д.
Одноко для оьектов такое ограничение отсутствует
```javascript
let obj = {
   for: 1,
   let: 2,
   return: 3
}
alert( obj.for + obj.let + obj.return );  // 6
// нет никаких ограничений к именам свойств
// по дефолту все имена свойств - сроки либо символы(с ними позже)

let obj = {
  0: "Тест" // то же самое что и "0": "Тест"
};

// обе функции alert выведут одно и то же свойство (число 0 преобразуется в строку "0")
alert( obj["0"] ); // Тест
alert( obj[0] ); // Тест (то же свойство)
```  
## Проверка существования свойства оператор in
В принципе получить безошибочно доступ к любому несуществующему свойству можно просто такое свойство будет undefined.  
И это будет носить хзарактер проверки
```javascript
let user = {}; // литерал

alert( user.noSuchProperty === undefined ); // true 
// оператор in

`key` in object

let user = {name: `wasya`, age: 30};
alert( `age` in user); // true такой есть
alert(`dfageds` in user); // false user.dfageds не существует
// кавычки означают образение именно по свойству(ибо они строки)
// обращение же без ковычек означает обращение по переменной
let user = { age: 30 };

let key = "age";
alert( key in user ); // true, имя свойства было взято из переменной key
```  
На деле оператор in нужен для замены обычной проверки на undefined только в случае если одной из свойств и есть undefined  

```javascript
let obj = {
  test: undefined
};

alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```  
## Цикл for...in
Используется для перебора всех свойств и отличается от for
```javascript
for (key in object){
   ...
   // выполняется для каждого свойства обьекта
}
let user = {
   name: `John`,
   age: 30,
   isAdmin: true
};

for(let key in user) {
   // алертаем ключи
   alert( key );// name age isAdmin
   // алертаем их значения
   alert(user[key]);// john 30 true
};
// такой порядок вывода означает что свойства в обьекте неким образом упорядочены об этом нижу
```
## Упорядолчение свойств обьекта
```javascript
let codes = {
   `49`: `Germany`
   `375`: `Belarus`
   `8`: `Russia`
   //...
   `1`: `USA`
};
for (let code in codes) {
   alert( code ); // 1, 8, 49, 375
};
//номера пойдут по возрастанию ибо являются целыми числами 
// такое еще называется целочисленным свойством 
// целый числа идут от 1 до бесконечности в порядке возрастания всегда
// но если свойства будут не целочисленными то они будут идти в порядке создания
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // добавим ещё одно свойство

// не целочисленные свойства перечислены в порядке создания
for (let prop in user) {
  alert( prop ); // name, surname, age
}
// таким образом если мы поставим унарный плюс перед каждым свойством они не будут целочисленными ибо "375" не тоже самое что и "+375"
let codes = {
   `49`: `Germany`
   `375`: `Belarus`
   `8`: `Russia`
   //...
   `1`: `USA`
};
for (let code in codes) {
   alert( +code ); // 49 375 8 1
};
// теперь все работает
```
 # копирование обьектов и ссылки  
 Одним из главных отличий обьектов от примитивов являчется то что они хранятся по ссылке  
 ```javascript
 // переменные присвиваются и копируются по значению(к примеру по строке в них)
let message = 'Hi'

//переменная хранит не сам обьект а его адресс в памяти или ссылку на него
let user = {
   name: 'wasya'
};
// обьект находится где то в памяти, а в переменной лежит ссылка на эту область памяти
// когда переменная копируется, сам обьект не дублируется, дублируется сама ссылка на обьект
let user = {
   name: 'wasya'
   status: 'admin'
};
let admin = user;
admin.name = 'Petya';
alert(user.name)// `Petya`
 ```
 ## сравнение
 ```javascript
// два обьекта равны только в том случае если это один и тот же обьект
let a = {};
let b = a;
alert(a == b); // true
alert(a === b); // true

let a = {};
let b = {};
a == b; // false
a === b; // false
// оба пусты но не равны
 ```
 ## Клонирование и обьединение. Object.assign  
Для того чтобы создать независимого клона обьекта мы должны перебрать свойства основного и копировать каждое.
 ```javascript
let user = { // основной обьект
   name: 'Isac',
   age: 30
};
let clone = {}; // место куда скопируется основной обьект

for (let key in user) { 
   clone[key] = user[key];
   // перебираем свойства оснвного обьекта и каждое присваиваем в пустой новый обьект
};

clone.name = 'Petya';
alert(user.name); // 'Isac' в основном свойство name не изменилось

// так же для реализации такого можно использовать метод Object.assign
Object.assign(dest, [src1, src2, src3....]);
// dest - целевой обьект
//остальные аргументы - исходные обьекты
// метод копирует все свойства исходныых обьектов в целевой обьект dest
// возвращает dest
let user = { name: 'Isac' };

let permission1 = { canView: true };
let permission2 = { canEdit: true };
//копируем свойсва обьектов выше в обект user
Object.assign(user, [permission1, permission2]);
// теперь user name isac, canView:true, canEdit: truel

// если целевой обьект уже имееет копируемоемое в него свойствоБ то оно будет перезаписанно.
let user = { name: "Иван" };
Object.assign(user, { name: "Пётр" });

alert(user.name); // теперь user = { name: "Пётр" }
 ```
 ## Вложенное клонирование  
 ```javascript
let user = {
   name: 'Isac',
   sizes: {
      hight: 182,
      width: 50
   }
};

alert(user.sizes.height) // 182
// недостаточно сделать предыдущие дествия т.к. теперь скопируется ссылка sizes на вложенный обьект а не сам вложенный обьект.
let user = {
   name: 'Isac',
   sizes: {
      hight: 182,
      width: 50
   }
};
let clone = Object.assign({}, user);

alert(user.sizes === clone,sizes) // true
// чтобы исправить это нужно в цикле клонирования сделать проверку не является ли свойство обьектом и если да, скопировать его сруктуру так же
// для таких действий можно использовать метод .cloneDeep(obj) из библиотеки lodash
 ```  
 # Сборка мусора  
 Обьекты непосредственно связаны с памятью и поэтому все манипуляции внутри происходят неведамо для глаза поэтому надо знать как это работает в корне.
 ## Достижимость
 Достижимые значения это те которые доступны или используются.Они гарантированно находятся в памяти  
   1. значения которые не могут быть удалены:  
+ Локальные переменные и параметры текущей функции
+ Переменные и параметры других функций в текущей цепочке вложенных вызовов.
+ Глобальные переменные
+ некоторые другие внутренние значения

Такие значения называются корнями  

   2. Любое другое значение является достижимым если оно доступно по ссылке из корня или цепочке ссылок.

В js есть фоновый процесс который называется **сборщик мусора**
Пример
```javascript
let user = {
   name: 'Isac'
};
//<global> -user- Object, name: 'Isac'

//-user- обозачает ссылку на обьект соответственно если перезаписать обьект будет потерян

user = null;
// теперь обьект isac стал недостижимым сборщик удалит его и освободит память
// но если скоприровать ссылку в другую переменную обьект не удалится
let admin = user
// теперь у нас остался доступ по друггой ссылке
```
## Взаимосвязанные обьекты
```javascript

function marry(man, woman) {// функция marry женит 2 обьекта
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
// функция marry женит 2 обьекта а так же возвращает новый обьект family со ссылками на оба предыдущих что же получится в итоге
// все обьекты буду взаимосвязанны ссылками друг с другом
delete family.father;
delete family.mother.husband;
// теперь у нас нет ни одной входящей ссылки к обьекту john, поэтому сборщик удалит его
```
**только входящие ссылки могут сделать обьект достижимым**
## Недостижимый остров
Если взять предыдущий обьект и удалить ссылку family мы удалим все ссылки на обьекты ниже wife и husband.  
Таким образом они станут недостижимы хотя и будут связаны друг с другом, как будто мы удалили целый остров данных.  
## Алгоритм работы сборщика мусора  

+ Сборщик мусора «помечает» (запоминает) все корневые объекты.
+ Затем он идёт по их ссылкам и помечает все найденные объекты.
+ Затем он идёт по ссылкам помеченных объектов и помечает объекты, на которые есть ссылка от них. Все объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
+ …И так далее, пока не будут посещены все ссылки (достижимые от корней).
+ Все непомеченные объекты удаляются. 

# Метод обьекта this
Методы существуют для совершения определенных действий над обьектом
## Примеры методов  
```javascript

let user = {
  name: "Джон",
  age: 30
};
//создаем и применяем метод к обьекту
user.sayHi = function() {
  alert("Привет!");
};

user.sayHi(); // Привет!

// сокращенный способ написания метода
//форма записи в литерале
user = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function()"
    alert("Привет");
  }
};
// обьекты выполнят одинаковые действие однако одно тонкое отличие есть связанное с наследованием обьектов
```
## Ключевое слово this в методах
```javascript
// this будет нормально работать только имея доступ к информации обьекта.
let user = {
  name: "Джон",
  age: 30,

  sayHi() {
    // this - это "текущий объект"
    alert(this.name);
  }

};

user.sayHi(); // Джон
// использовать метод this надёжнее чем прямую ссылку user !!!!!!!!!!!!!!!!!!!      
```
## this не является фиксированным
то есть постоянно меняет свой фокус 
```javascript
function sayHi() {
   alert( this.name );
}// не будет ошибкой
// Значение this вычисляется во время исполнения кода и зависит от контекста
let user = { name: 'Isac' };
let admin = { name:'Admin' }; 

function sayHi() {
  alert( this.name );
};
// одна и та же функция в 2 обьектах
user.f = sayHi;
admin.f = sayHi;
// однако в каждом this разный
// "this" внутри функции является ссылкой на объект, который указан "перед точкой"
user.f(); // Джон  (this == user)
admin.f(); // Админ  (this == admin)

admin['f'](); // Админ (неважен способ доступа к методу - через точку или квадратные скобки)

// вызов this без обьекта будет == undefined

// у стрелочных функций нет собственного this
// если использовать this внутри стрелочной функции то значения this берутся из внешней нормальной функции
let user = {
   firstNmae: 'Isac',
   sayHi() {
      let arrow = () => alert(this.firstName);
      arrow();
   }
};
// arrow() использует значение this из внешнего метода sayHi
user.sayHi(); // Isac 
```  
# Конструкторы создание обьектов через new
синтаксис литерала {} позволяет сделать лишь 1 обьект но порой надо сделать много однотипных обьектов в таком случае на помощь приходит оператор new
## Функция конструктор   
функция котснтруктор 1.**имя начинается с большой буквы** 2.**должна вызываться при помощи оператора new**.  
```javascript
function User(name) {
   this.name: name;
   this.isAdmin: false;
};

let user = new User('Wasya');
alert(user.name); // Wasya
alert(user.isAdmin); // false
// когда происходит выхов функции с помощью new происходит:
// создается пустой обьект и присваивается this
// выполняется код функции(обычно присваивает в this свойства)
// возвращает значение this
// грубо говоря вот что происходит

function User(name){
   // this = {}, неявно
   //добовляет свойства в this
   this.name: 'wasya';
   this.isAdmin: false;
   // return this неявно
}
// когда будет необходимо создать других пользователей можно просто использовать new User('igor') new User('Isac');
```
Нужно заметить что любую функцию можно вызвать через new и выполнится алгоритм описанный выше, большая буква просто подсказывает что функция является конструктором и ее следует вызывать через new.  
<details><summary>Оптимизация кода</summary>  

new function() {...}
```javascript
// если в коде много строк создающих один сложный обьект можно обернуть это в функцию конструктор
let user = new function() {
   this.name: 'wasya';
   tis.age: 30;

 // ...другой код для создания пользователя
// возможна любая сложная логика и выражения
// локальные переменные и т. д.
}
//такой конструктор не может быть вызван дважды так как он нигде не сохраняется, просто создается и тут же вызывается. Таким образом он создает обьект но без возможности его повторного использования.
```

</details>  

## Провера на вызов new.target
Проверяет функция вызвана при помощи new или без него, если да вернет саму функцию в противном случае undefined.  
```javascript
function User() {
   alert(new.target);
};
User(); // undefined
new User(); // function User {...};
```  
## Возврат значения из конструктора return
Обычно return сам по себе происходит неявно  
Однако если все return есть, то применяется правило  
+ при вызове return с обьектом, будет возвращен обьект, а не this.
+ при вызове return с примитивным значением, примиивное значение будет отброшено.  

return с обьектом возвращает обьект, в любом другом случае коструктор вернет this
```javascript
function BigUser() {
   this.name = 'wasya';

   return {name: 'Godzilla'}; // возвращает этот обьект
}
alert(new BigUser().name) // Godzilla получили этот обьект  
function SmallUser() {
   this.name = 'Wasya';

   return; // вернет this
}
alert(new SmallUser().name) // Wasya  

// если аргументы передавать не нужно
```  
<details><summary>скобки при вызове new</summary>  

Можно не использовать скобки при вызове если не нужно передаваь аргументы
```javascript
let user = new User; // без тоже что и 
let user = new User();
```

</details>  

## Создание методов в конструкторе  
Можно передовать конструктору параметры как создавать обьект и что записывать

```javascript
function User(name) {
   this.name = name; // данное имя

   this.sayHi = fubction() { // метод sayHi
      alert('Меня зовут' + this.name);
   };
}
let vasya = new User('Wasya');
vasya.sayHi();// меня зовут Wasya
```

