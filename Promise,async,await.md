# Введение, колбэки
Многие действия в js ассинхронны
к примеру загрузка нового скрипта
```javascript
function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
loadScript('/my/script.js');
```
Когда конструкция script добавится в браузер браузер загрузит прочтёт и выполнит его, однако код находящий после вызова функции ждать не собирается и выполняется не дожидаясь закгрузки скрипта.  
Воизбежании ошибок по типу скрипт недогрузился а код уже пытается использовать переменные из него, придуманы функции колбэки.
```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}
// теперь для вызова функции из скрипта делать жто нужно в коллбэке
loadScript('/my/script.js', function()) {
  //вызовется сразу ПОСЛЕ загрузки скрипта
  newFunction()
}
```
в callback передается функция использование таких приёмов обзывается асинхронным программированием с использованием коллбэков.  
Смысл в том что передаётся функция которая выполняется по завершению действий предыдущей функции(здесь загрузка скрипта.).  
### Для загрузки большего количества скриптов по порядку можно использовать коллбэк в коллбэке
```javascript
loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...и так далее, пока все скрипты не будут загружены
    });
  })
});
```
Такое решение подходит лишь в случае когда надо подгрузить еще 1 -2 доп скрипта.  
## Перехват ошибок  
Монжно и нужно докидывать функционал в коллбэк который бы отслеживал ошибки  
```javascript
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error('не удалось грузануть скрипт ${src}'));
  document.head.append(script);
}
```
Теперь в случае ошибки загрузки, ошибка будет явно видна.
### Такой приём называет КОЛЛБЭК С ПЕРВЫМ АРГУМЕНТОМ-ОШИБКОЙ  
## Адская пирамида вызовов  
Возникает в случае когда нужно делать много асинхронных дествий друг за другом, вложенность растёт, пирамида растёт в право, читабельность сильно теряется.  
Такая большеуровневая вложенность крайне неприветствуется.
P.S. разбитие кода на блоки еще сильнее усугубит ситуацию, поэтому для решения этой проблемы придуманы промисы.
# Промисы
1. есть код который что либо создаёт, загружает(неважно) важно что он тратит на это время - СОЗДАЮЩИЙ  
2. Есть код который ожидает создание в создающем коде и обрабатывает какие либо данные из него - ПОТРЕБЛЯЮЩИЙ  

Promise – это специальный объект в JavaScript, который связывает код делающий какие либо действия определенное время и код получающий от предыдущего кода информацию вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.
Синтасис
```javascript
let promise = new Promise(function(resolve, reject){
// функция создающая(executor)
}); 
```
- В конструкцию new Promise вписывается функция создатель.  
- аргументы resolve и reject - коллбэки которые предоставляет сам js, код который нужно делать находится лишь внутри конструкции
  - resolve(value) - если работа завершилась успешно с результатом value
  -  reject(error) - не успешно с ошибкой error

Итак запускается автоматом код исполнитель а затем вызваает resolve или reject  
У получаемого обьекта ``promise`` от конструктора есть внутренние свойства
- state - (состояние) 
  - pending - ожидание
  - fulfilled - выполненно успешно
  - rejected - выполненно с ошибкой
- result - результат
  - undefined - 1 стадия
  - value - при вызове resolve(value)
  - error - при reject(error)

### Вернуть промис может лишь что то одно рзёльтат или ошибка!!
### resolve и reject можно вызывать мгновенно не дожидаюсь результатов функции.
### state и result внутренние свойства обьекта promise к ним нет прямого доступа  
## Потребители then catch finally
Функции ожидающие результатов от функции создающей прописываются при помощи методов .then .catch .finally
### then  
```javascript
promise.then{
  function(result){}// обработка успешного выполнения
  function(error) {}//обработка ошибки
};

let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);
```  
### catch
Метод catch обрабатывает ошибки
```javascript
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject (new Error('Ошибка!')), 1000);
});
promise.catch(alert);// выведет ошибку
```
### finally
по аналогии с try catch выполняется внезависимости от упеха выполнения промиса
```javascript
new Promise ((resolve, reject) => {
  //четоделать
})
.finally(() => сделать что либо(к примеру остановить индикатор загрузки));
.then(() => показать результат, err => показать ошибку)
```
### обработчик finally пропускает результаты/ ошибку дальше к след обработчика
### обработчик из finally не имеет аргументов 

ДОДЕЛАТЬ