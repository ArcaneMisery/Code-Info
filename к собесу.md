# Замыкание  
### Замыкание функция которая запоминает свои внешние переменные и может получить к ним доступ.  
В некоторых языуках это невоможно либо функция должна быть написана специальным образом. **Но в js все функции являются замыканиями** кроме синтаксиса new Function.  
## Техническая часть замыкания  
Все глобальное тело кода есть свойства большого обьекта Enviroment record. То есть все переменные и тд записываются как его ключи и свойства. Записываются они туда в момента прочитывания их в коде.  
Когда вызываются и обьявляются функции они инициализируются раньше переменных, когда создается лексическое окружение.  
Когда создается любая функция в ней появляется свое скрытое свойство [Enviroment]- внутреннее лууксическое окружение.  
Когда функция срабатывает, происходит считывание трёх этапов:  
Внутреннее окржуение => внешнее окружение(если есть вложенная функция) => глобальное окружение  
**Таким образом функция всегда получает значение текущего(последнего) состояния переменной**  
## Доп инфа  
К любой части кода в ``{}`` приписывается скрытое совйство [Enviroment]. Область видимости таких блоков кода является той же что у функций.  
К при меру блок ``for (let...) {smth}`` или ``if(){smth}`` имеет такое же поведение как функция.  
### Сборка мусора  
Все работает стандартно, функция выполнилась и удалилась из памяти, но если у функции есть вложенная функция ссылающаяся на область памяти внешней, она останется достижимой и не удалится из памяти.  
```javascript
function f() {
  let value = 123;
  function g() { alert(value); }
  return g;
}
let g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти
```


# Рекурсия и стек  
## Рекурсия
### Рекурсия это метод создания функции в которой происходит вызов самой себя тем самым разделяя задачу на более простые части.  
Для лучшего понимания можно представить задачу которую можно решить через цикл, либо через условное ветвление, в котором если условие не выполняется функция вызывает сама себя, если условие выполняется возвращается результат.  
Тем путем самовызова функции заменяется цикл  
```javascript
// решение задачи возведения числа в степень рекурсивным методом
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) ); // 8
```
**Стоит помнить** что рекурсивный метод занимает большее количество памяти и в целом менее эффективен чем цикл, но в определенных случаях выигрывает у цикла во много раз.  
## Стек  
Или как там все работает изнутри.  
Вся информация о том процессе выполнения функции находится в контексте выполнения.  
**Контекст выполнения** - Специальная структура данных которая содержит в себе информацию о месте в коде на котором находится интерпретатор, локальные переменные функции, значение ``this``, и т.д..  
Когда происходит вложенный выхов случаются след дествия
+ Выполнение функции приостанавливается.  
+ Контекст выполнения сохраняется в стеке контекстов выполнения
+ Выполняются вложенные вызовы для каждого из которых создается свой контекст выполнения.
+ После их завершения старый контекст удаляется из стека и выполнение внешшней функции продолжается с момента остановки.

На деле все выглядит так  
1. Идет первый вызов внешний, создается его контекст.Вызов доходит до момента вызова самого себя.  
2. Чтобы вызвать саму себя, js запоминает прошлый контекст выполнения в стеке контекстов. Происходит вызов вложенный, его контекст ззаписывается на вершину стека. Дальше выполнение вложенного вызова завершается и js возврщается к внешней функции, запомнив 2 контекста в стеке.
3. Процесс повторяется, новый контекст добовляется в стек, но к примеру теперь функция саму себя не вызывает, условие которое остановит рекурсию выполняется и возвращается результат,в таком случае происходит
4. Выход. Вложенных вызовов больше нет поэтому функция завершается дойдя до самого простого варианта. Стек контекстов чистится поочередно удаляя текущий и возвращая предыдущий, чистка доходит до последнего внешнего выззова которыый и возвращает нужный результат.  

Именно из за таких манипуляций памяти рекурсия в большинстве неэффективна по сравнению с циклами, хоть и смотрится лучше.  
Исходя из всего выше описанного
### Стек - это некая очередь элементов, в которой добавляются и удаляются элементы с одного конца этой очереди.  
## Пример когда реально нужно использовать рекурсию вместо цикла.  
Есть Массив обьектов разных уровней вложенности, со свойствами обьекта надо что либо сделать, изходя из предыдущих тем, чтобы достучаться до все вложенностей, нужно создать соответственное кол - во циклов.  
Рекурсия решает эту проблему.
```javascript
let company = { // обьект вложенностей
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};
// нужно подсчитать зарплату (свойство salary)
function sumSalary(department) {
  if(Array.isArray(department)){  // условие остановки рекурсии
    // проверка если вернулся массив то функция вычислит сумму его элементов
    return department.reduce((prev, cur) => prev + cur.salary, 0)
  }else{
    // рекурсия
    let sum = 0;
    for (let subdep of Object.values(department)) {
      // вызывается для подотделов, суммируя их по вложенностям
      sum += sumSalaries(subdep);
    }
    return sum;
  }
}
console.log(sumSalaries(company)); // 6700
```
