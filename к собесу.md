# Замыкание  
### Замыкание функция которая запоминает свои внешние переменные и может получить к ним доступ.  
В некоторых языуках это невоможно либо функция должна быть написана специальным образом. **Но в js все функции являются замыканиями** кроме синтаксиса new Function.  
## Техническая часть замыкания  
Все глобальное тело кода есть свойства большого обьекта Enviroment record. То есть все переменные и тд записываются как его ключи и свойства. Записываются они туда в момента прочитывания их в коде.  
Когда вызываются и обьявляются функции они инициализируются раньше переменных, когда создается лексическое окружение.  
Когда создается любая функция в ней появляется свое скрытое свойство [Enviroment]- внутреннее лууксическое окружение.  
Когда функция срабатывает, происходит считывание трёх этапов:  
Внутреннее окржуение => внешнее окружение(если есть вложенная функция) => глобальное окружение  
**Таким образом функция всегда получает значение текущего(последнего) состояния переменной**  
## Доп инфа  
К любой части кода в ``{}`` приписывается скрытое совйство [Enviroment]. Область видимости таких блоков кода является той же что у функций.  
К при меру блок ``for (let...) {smth}`` или ``if(){smth}`` имеет такое же поведение как функция.  
### Сборка мусора  
Все работает стандартно, функция выполнилась и удалилась из памяти, но если у функции есть вложенная функция ссылающаяся на область памяти внешней, она останется достижимой и не удалится из памяти.  
```javascript
function f() {
  let value = 123;
  function g() { alert(value); }
  return g;
}
let g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти
```


# Рекурсия и стек  
## Рекурсия
### Рекурсия это метод создания функции в которой происходит вызов самой себя тем самым разделяя задачу на более простые части.  
Для лучшего понимания можно представить задачу которую можно решить через цикл, либо через условное ветвление, в котором если условие не выполняется функция вызывает сама себя, если условие выполняется возвращается результат.  
Тем путем самовызова функции заменяется цикл  
```javascript
// решение задачи возведения числа в степень рекурсивным методом
function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
alert( pow(2, 3) ); // 8
```
**Стоит помнить** что рекурсивный метод занимает большее количество памяти и в целом менее эффективен чем цикл, но в определенных случаях выигрывает у цикла во много раз.  
## Стек  
Или как там все работает изнутри.  
Вся информация о том процессе выполнения функции находится в контексте выполнения.  
**Контекст выполнения** - Специальная структура данных которая содержит в себе информацию о месте в коде на котором находится интерпретатор, локальные переменные функции, значение ``this``, и т.д..  
Когда происходит вложенный выхов случаются след дествия
+ Выполнение функции приостанавливается.  
+ Контекст выполнения сохраняется в стеке контекстов выполнения
+ Выполняются вложенные вызовы для каждого из которых создается свой контекст выполнения.
+ После их завершения старый контекст удаляется из стека и выполнение внешшней функции продолжается с момента остановки.

На деле все выглядит так  
1. Идет первый вызов внешний, создается его контекст.Вызов доходит до момента вызова самого себя.  
2. Чтобы вызвать саму себя, js запоминает прошлый контекст выполнения в стеке контекстов. Происходит вызов вложенный, его контекст ззаписывается на вершину стека. Дальше выполнение вложенного вызова завершается и js возврщается к внешней функции, запомнив 2 контекста в стеке.
3. Процесс повторяется, новый контекст добовляется в стек, но к примеру теперь функция саму себя не вызывает, условие которое остановит рекурсию выполняется и возвращается результат,в таком случае происходит
4. Выход. Вложенных вызовов больше нет поэтому функция завершается дойдя до самого простого варианта. Стек контекстов чистится поочередно удаляя текущий и возвращая предыдущий, чистка доходит до последнего внешнего выззова которыый и возвращает нужный результат.  

Именно из за таких манипуляций памяти рекурсия в большинстве неэффективна по сравнению с циклами, хоть и смотрится лучше.  
Исходя из всего выше описанного
### Стек - это некая очередь элементов, в которой добавляются и удаляются элементы с одного конца этой очереди.  
## Пример когда реально нужно использовать рекурсию вместо цикла.  
Есть Массив обьектов разных уровней вложенности, со свойствами обьекта надо что либо сделать, изходя из предыдущих тем, чтобы достучаться до все вложенностей, нужно создать соответственное кол - во циклов.  
Рекурсия решает эту проблему.
```javascript
let company = { // обьект вложенностей
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};
// нужно подсчитать зарплату (свойство salary)
function sumSalary(department) {
  if(Array.isArray(department)){  // условие остановки рекурсии
    // проверка если вернулся массив то функция вычислит сумму его элементов
    return department.reduce((prev, cur) => prev + cur.salary, 0)
  }else{
    // рекурсия
    let sum = 0;
    for (let subdep of Object.values(department)) {
      // вызывается для подотделов, суммируя их по вложенностям
      sum += sumSalaries(subdep);
    }
    return sum;
  }
}
console.log(sumSalaries(company)); // 6700
```
# Устаревшее слово var  
Слово var не имеет блочной области видимости, они ограничены как минимум, телом функции.    
Если var находится в блоке кода внутри функции то var станет локальной переменной для этой функции.     
Обьявление var name можно делать сколько угодно раз и это не вызовет ошибки.  
Обьявление или инициализация переменных var происходит в начале выполнения скрипта/функции, а значение к ним присваивается в строчке в которой оно указано  
# Глобальный обьект  
Глобальный обьект или window в браузере или global в Node.js , в зависимости от среды разработки, представляет переменные и функции доступные в любом месте программы.  
+ Универсальное имя глобального обьекта - globalThis.  
+ В глобальном обьекте следует хранить только действительно нужные глобальные значения для проекта, стараться сводить их кол-во к минимуму.  
+ чтобы код был проще и легче следует обращатся к обьекту напрямую по типу ``window.x``  
  




# В чем смысл оборачивания всего содержимого JavaScript-файла в функцию ?    

<details> <summary>Подсказка</summary>  

Такое называется IIFE imidiatelly invoked function expression, такой подход позволяет  
- Обеспечить коду свой блок видимости 
- Избежание загрязнения глобальной области видимости переменными  
- Избежать случайного переделения переменных в глобальной области видимости

</details>  

# hoisting - поднятие в js что это  

<details> <summary>Подсказка</summary>

Это поведение js при загруззке скрипта заключающееся в поднятии функкций и обьявлений переменных на верх области видимости


</details>    

# Что такое this?   
<details> <summary>Подсказка</summary>

this указывает на обьект области видимости в момент выполнения, По умолчанию this === window.

</details>    

# Объясните, почему запись function foo(){}() вызывает ошибку и не работает, как IIFE?  

<details> <summary>Подсказка</summary>

Здесь дело в том, что круглые скобки вызова функции добавлены сразу после Function Declaration. Однако, они могут следовать только за выражением (expression). Поэтому мы должны либо прибегнуть к варианту с Function Expression, либо обернуть Function Declaration в скобки, тем самым превратив его в выражение.
```javascript
conts foo = function(){}();
(function foo(){})();
(() => {})()
```

</details>   

# В каких случаях используются анонимные функции?  

<details> <summary>Подсказка</summary>


Анонимные функции чаще всего используются в качестве функций обратных вызовов. Также, каждая стрелочная функция является анонимной.

</details>  

# В чем разница между Function.prototype.call и Function.prototype.apply?  

<details> <summary>Подсказка</summary>

Оба метода вызывают исходный метод с подмененным контекстом, но .call принимает параметры через запятую, а .apply - массивом.

</details>  

# Как работает Function.prototype.bind?  

<details> <summary>Подсказка</summary>

Метод возвращает функцию к которой он применяется но с подмененным констекстом, Подмененный контекст включается в функцию как постоянный дополнительный аргумент

</details> 

# Почему лучше оставлять глобальную область видимости "как есть" и не трогать ее?  

<details> <summary>Подсказка</summary>

Свойства глоабльной области видимости может изменить любой js код имеющий к ней доступ, также гроит конфликтами имён.

</details>  

# Какие инструменты вы используете при отладке?  

<details> <summary>Подсказка</summary>

console.log(), браузерный отладчик

</details>   

# В чем разница между let, const и var?

<details> <summary>Подсказка</summary>

var
- поднимается в начало области видимости функции при компиляции
- объявляет переменную, которая может быть перезаписана
- объявляет переменную, которая может быть переопределена  

let
- поднимается в начало области видимости блока при компиляции
- объявляет переменную, которая может быть перезаписана
- объявляет переменную, которая не может быть переопределена  

const
- поднимается в начало области видимости блока при компиляции
- объявляет переменную, которая не может быть перезаписана или переопределена

</details>   

# Что такое функция высшего порядка?  

<details> <summary>Подсказка</summary>

Функция принимающая функцию обратного вызова в качестве аргумента

</details>   

# В чем разница между оператором «in» и методом hasOwnProperty?  

<details> <summary>Подсказка</summary>

Отличие состоит в том, что оператор «in» проверяет наличие свойства не только в самом объекте, но и в его прототипах, а метод hasOwnProperty — только в объекте.

</details>    

#  В чем разница между методами Object.freeze и Object.seal?  

<details> <summary>Подсказка</summary>

Разница заключается в том, что при использовании метода Object.freeze мы не можем менять или редактировать свойства объекта, а при использовании Object.seal у нас такая возможность имеется.

</details> 

# 4 способа вызова функции в js 

<details> <summary>Подсказка</summary>

Вызвать можно как  
- обычную функцию
- метод
- функицю конструктор
- с помощью методов call aply

</details>  

# Файлы Cookie  
<details> <summary>Подсказка</summary>

Это небольшой фрагмент данных отправленных сервером и хранимый на компьютере. Браузер при открытии страницы отправляет эти данные в составе http запроса, используется для  
- аутентификации  
- хранения перс. предпочтений и настроек  
- отслеживание состояния сеанса  
- сведений статистики

</details>  

# Максимальный размер cookie  
<details> <summary>Подсказка</summary>

от 4096 битов до 4кб

</details>  

# Версии HTTP протокола  
<details> <summary>Подсказка</summary>

HTTP 0.9 , HTTP 1.0 , HTTP 1.1 , HTTP 2 

</details>  

# Методы HTTP запросов
<details> <summary>Подсказка</summary>

как в формах, GET, POST; CONNECT, PUT, DELETE, OPTIONS, TRACE

</details>  