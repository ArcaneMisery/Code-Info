# Остаточные параметры. Оператор расширения
## Остаточные параметры [...]  
Работает это так что [...args] собирает все переданные в функцию данные в массив.
```javascript
function sumAll(...args) {
  let sum = 0;

  for (let arg of args) sum += arg;
  return sum;
}
console.log( sumAll(1));
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6
```
Можно использовать так чтобы сложить несколько данных в переменные а остальное в массив
```javascript
function showName(firstName, lastName, ...titles) {
  console.log(firstNmae + '' + lastName);
}
showName("Юлий", "Цезарь", "Консул", "Император");
// Консул и Исператор собрались в массив titles
```
**ОСТАТОЧНЫЕ ПАРАМЕТРЫ ОБЯЗАТЕЛЬНО ДОЛЖНЫ РАСПОЛАГАТЬСЯ В КОНЦЕ**

## Не много про arguments  
Все аргументы функции находятся в псевдомассиве(обьекте) arguments
(practic/js важные пометки):
**Стрелочные функции не имеют arguments**
## Оператор расширения  
Получает список параметров из массив (абсолютно наооборот в отличии от предыдущего)
```javascript
let a = [3, 5 ,1];
console.log(Math.max(...a))// 5 оператор раскрыл значения массива

// можно передать несколько итерируемых обьектов
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
console.log(Math.max(...arr1, ...arr2)); 

// можно комбинировать с обычными значениями

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
console.log(Math.max(6, ...arr1, 1, ...arr2, 25)); 

// Можно использовать для слияния массивов

let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
console.log(merged) //0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)

// превращение строки в массив

let str = "Привет";
// Array.from преобразует перебираемый объект в массив
alert( [...str] ); // П,р,и,в,е,т
```
**Оператор расширения практически безграничен и работает с любым перебираемым обьектом**  
**Как это работает**  
Оператор расширения использует итераторы чтобы перебирать элементы как цикл for of.  
По сути ...obj работает идентично Array.from(obj). Но есть одно важное отличие.  
+ ``Array.from(obj)`` работает как с итерируемыми обьектами так и с псевдомассивами  
+ Оператор расширения работает только с итерируемыми обьектами 

# Обьект функции, NFE 
В js функции это обьект и как и у обычных обьектов у функций тоже есть ствой свойтсва.
## свойство name
func.name - получает имя функции либо название переменной в которую она записана
```javascript
function sayHi = function() {
  console.log('Hi');
}
let sayHi = function(){

}
console.log(sayHi.name) // в обоих случаях присвоится имя sayHi

function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (работает!)
}
f();
```
Такой манёвр когда не задано имя функции называется **контекстным имя** js пытается определить имя из контекста    
Имена имеют и методы обьекта
```javascript
let user = {

  sayHi(){
  },
  sayBye: function() {
    //...
  }
} 
console.log(user.sayHi.name)// sayHi
console.log(user.sayBy.name)// sayBi
```
Однако может быть ситуация в которой конкретное имя определить невозможно
```javascript
let arr = [function() {}];
console.log(arr[0].name) // ''
// нет возможности определить имя так как его нет
```
## Свойство length
Возвращает количество параметров функции в её обьявлении
```javascript
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```
Остаточные параметры как бы не считаются в св-во length    
Зачастую это свойство используется в функциях которые работают с другими функциями
## Пользовательские свойства  
Можно создавать свои свойства для функций  
К примеру свойство для подсчета вызовов функции  
```javascript
function sayhi() {
  console.log('hi')

  sayHi.counter++
}
sayHi.counter = 0

sayHi(); // Hi
sayHi(); // Hi
console.log(sayHi.counter) // 2
```
**Свойство функции не есть переменная**, можно использовать функцию как обьект и хранить в ней свойства, но они ни как не влияют на её выполнение, свойства это не переменные и наоборот это два парралельных мира.  

## Named Function Expression  
NFE - это термин для function expression у которого есть имя  
Проще говоря это задание имени функции когда функция складывается в переменную, нужно это для того чтобы безопасно делать самовызовы функции, ибо если делать такие вызовы через переменную функции, переменная может изменится и код вызовет ошибку  
# Синтаксис new function
Еще один вариант вызова функции
``let func = new function([arg1,arg2,...argN], body)``  
Главное отличие такого подхода в том что функция создаётся в момент чтения из строки, переданной во время выполнения.  
new function может превратить любую строку в функцию, к примеру передана функция строкой
```javascript
let str = '....' // код полученнй с сервера
let func = new function(str);
func();
```
## из темы замыкания  
Функции запоминают где были созданы с помощью свойства enviroment, но функции обьявленные в new дествуют наоборот, в их enviroment записывается ссылка на внешнее лексическое пространство.Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что страхует нас от ошибок. Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.  
# Планирование: setTimeout и setInterval  
Вызов функции через некое время.
+ ``setTimout`` - позволяет вызвать функцию **один раз** через определённый промежуток времени.  
+ ``setInterval`` - позволяет вызывать функцию регулярно через определённый промежуток времени.  

## setTimeout  
```javascript
let timeout = setTimeout(func|code, [delay],[arg1], [arg2], ...) 
```
**func|code** - функция или строка кода для выполнения, обычно передается функция, сроку передавать не стоит, она там есть по историческим причинам.  
**delay** - задержка перед запуском, в мс(1000мс === 1с), по умолчанию 0.  
**arg1,arg2...argN** - Аргументы передаваемые в функцию (не подерживаются в IE9)  
```javascript
function hello () {
  consol.log('hi!')
}
setTimeout(hello, 1000);
// вызовет функцию через секунду
// с аргументами
function hello (phrase, who) {
  console.log(phrase + ', ' + who);
}
setTimeout(hello, 1000, 'hello', 'john')

// ЕСЛИ ПЕРВЫЙ АРГУМЕНТ ЯВЛЯЕТСЯ СТРОКОЙ JS СДЕЛАЕТ ИЗ НЕЕ ФУНКЦИЮ
setTimeout('console.log('darova')', 1000);
// однако лучше для таких трюков использовать функции
settimeout => (() => console.log('darova'), 1000);
```  
## Отмена через clearTimeout
setTimeout - возвращает итендификатор таймера, который можно записать в переменную и использовать для отмены  
```javascript
let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
alert(timerId); // идентификатор таймера
clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)
```  
## setInterval  
имеет такой же синтаксис
```javascript
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
//выводить tick каждые 2 секунды
let timerId = setIterval(() => console.log('tick'), 2000);
// остановить выполнение и написать стоп через 5 сек
setTimeout(() =>  {clearInterval(timerId); console.log('stop');}, 5000);
```
## Вложенный setTimeout  
Есть второй способ запускать что то регулярно
```javascript
let timerId = setTimeout(function tick() {
  console.log('tick');
  timerId = setTimeout(tick, 2000); //
}, 2000)

// Такая запись пускай длиннее но в разы более гибкая чем через setInterval, можно использовать результат предыдщей функций и в зависимости от него делать след вызов

// например проверка на загруженность, сервис должен отправлять запрос для получения данных на сервер каждые 5 сек, если сервер перегружен , уменьшить интервал до 10 20 40 сек  
let delay = 5000  
let timerId = setTimeout(function request() {
  ...отправка запроса....
  if(erorr: server is overload) {
    delay *= 2;
    //увеличение дилея
  }
  timerId = setTimeout(request, delay);
}, delay)
```  
Разница в использовании setInterval и stTimeout, так же заключается в том что при setInterval реальная задержка больше чем указано в коде, и это нормально, потому что функция выполняемая внутри setInterval использует немного интервального времени на свое выполнение  
Вложенныый setTimeout же гарантирует фимксированную задержку, тк новый вызов планируется в конце предыдущего.
## Сборка мусора  
Когда функция передается в setTimeout либо setInterval, на нее создаётся внутренняя ссылка и созраняется в планировщике, такое поведение предотваращает попадание функции в сборщик мусора пока ссылка на нее хранится в планировщике. Другими словами функция в setInterval вообще никогда, только если не будет вызван clearInterval.  
Лучше всегда их так чистить ибо переменные и прочее созраняется в лексическом окружении.  
## нулевая задержка. Подводный камень  
Особый дилей - 0 вызывает функцию так быстро как только может, но после завершения выполнения текущего кода  
```javascript
setTimeout(() => console.log('hi'));
console.log('world');
// первым world вторым hi
```  
**Ограничение на нулевые дилеи и кол-во таймеров в браузере**  
В браузере при  наличии более 5 вложенных таймеров, интервал должен составлять не менее 4мс  
# Декораторы и переадресация вызова, call/apply  
## прозрачное кеширование  
Допустим есть функция которая делает вычисление и возвращает стабильный результат для передаваемого x аргумента в нее, другими словами для одного и того же аргумента x будет одинаковый результат. Чтобы не тратить время на повторные вычисления можно заставить функцию запоминать результат, но не увеличивая ее функционал, а создав функцию обёртку на ней
```javascript
function slow(x) {
  console.log(`Called with ${x}`);
  return x;
}
// функция обертка для кеширования
function cachcingDecorator(func) {
let cache = new Map;
return function(x) {
  if (cache.has(x)) {
    return cache.get(x)
    }
  let result = func(x);

  cache.set(x, result);
  return result;
  };
}
slow = cachingDecorator(slow);
console.log(slow(1) ); // выполненная функция закешировалась
console.log('again' + slow(1)) // взялась из кеша и вернулась
```  
Такое называется обёрткой ибо функция оригинальная проходит через логику кэширования и возвращает результат  
## Применение func.call для передачи контекста(если аргумент один)  
Кеширующий приём выше не будет работать с методами обьектов.
```javascript
let worker = {
  someMenthod() {
    return 1;
  }
  slow(x) {
    console.log('Called with' + x)
    return x * this.someMethod
  }
}
```
 Проблема заключается в том что на момент присвоения в переменную result, результат выполнения функции slow(x), this применяемый к методу будет undefined, и кеш вернет ошибку прочтения метода.  
 **Для работы с обьектами существует специальный метод func.call(context, ...args)**.  
 Он запускает функцию, используя первый ее аргумент как контекст this, а последующие как ее аргументы.  
 Проще говоря оба вызова делают одно и тоже, одно различие заключается что колл присвоет obj в this
 ```javascript
func(1,2,3)
func(obj, 1,2,3);  

// так используется кол на практике 
// call используется для вызова say  с определенным контекстом и фразой  
function say(phrase) {
  console.log(this.name + ':' + phrase);
}
let user = {name: 'John'};
say.call(user, 'Hello');
// user становится this и hello становится первым аргументом
// в случае превого примера достаточно поменять способ присвоения в переменную result 
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // теперь 'this' передаётся правильно
    cache.set(x, result);
    return result;
  };
}
worker.slow = cachingDecorator(worker.slow)
 ```  
 Как все работает глубже  
 1. после дкорации worker.slow становится оберткой function(x){}
 2. Так что при выполнении worker.slow(x), обёртка получает x в качестве аргумента и this = worker.
 3. Внутри обёртки если рещультат еще не кеширован, func.call(this, x) передаст текущий this и текущий аргумент в оригинальную функцию  
  
## Несколько аргументов с func.apply  (если аргументов много)  
Еще больше универсальности для кеша  
```javascript
let worker = {
  slow(min, max) {
    return min + max
  }
}
wokrek.slow = cachingDecorator(worker.slow);
```
Итак задача записать в кеш 2 аргумента и их результат.  
Исходя из нее строятся две другие.  
Во первых как записать в Map пару таких значений, если Map поддерживает только одно как ключ.Для решения превсой такой задачи существует множетсво решений  
1. Создать новую или взять строннюю более универсальную структуру данных.  
2. Использовать вложенных коллекции. cache.set(min) будет Map, которая хранит папку (max, result). Тогда получить result можно вызвав cache.get(min),get(max)
3. Соеденить 2 значения в одно, конкретно тут можно использовть строку 'min,max' как ключ к Map.Дополнительно можно сделать хеширующую функцию в декораторе, которая понимает как сделать одно значение из множества  

Восновном используют 3 вариант за счёт своей простоты и минимальности действий.
Вторая задача в изменении ``func.call(this, x)`` на ``func.apply(this, ...args)``, для передачи всех ргументов в обёртку а не только первого.  
Описание этого в скрипте:
```javascript
let worker = {
  slow(min, max) {
    return min + max
  }
}
function cashingDecorator(func, hash) {
  let cache = new Map;
  return function() {
    let key = hash(arguments); // вызывается функция hash складывающая значения
    if (cache.has(key)) {
      return cache.get(key)
    }
    let result = func.call(this, ...arguments); // передаётся контекст и все аргументы к нему
    cache.set(key, result);
    return result;
  };
}

function hash (args) {
  return args[0] + ',' + args[1];
}
worker.slow = cachingDecorator(worker.slow, hash);
```  
Вместо func.call можно было бы вписать ``func.apply(context, args)`` отличие в том что apply принимает список аргументов в качестве псевдомассива, а в call используется оператор расширения ... и принимает перебираемый обьект.  
Передача всех аргументов вместе с контекстом функци называется **перенаправлением вызова** происходит он на моменте применения call.apply так как call.apply и берет все данные функции.  
## Заимствование метода  
Применение методов массива к обьектам.  
```javascript
function hash(args) {
  return [].join.call(arguments);
}
hash(1, 2);
```  
Берётся метод join из обычного массива [].join и используется [].join.call чтобы выполнить его в контексте arguments.  
и так join метод массива сработал на обьекте, почему так?  
Это связано с тем что arr.join() метод очень прост в исполнении, как все происзошло  
1. Пусть первым аргументом будет x в случае отсутствия будет запятая.  
2. пусть result Будет строкой  
3. Добавить this[0] к result
4. добавить x и this[1]
5. добавить x и this[2]
6. выполняется до тех пор пока this.length не будет склеена
7. Вернуть result  
  
# Привязка контекста к функции  
Тема дополнение, нужно во время потери контекстав this в момент передачи обьектов из функций в функцию  
```javascript
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};
setTimeout(user.sayHi, 1000); // Привет, undefined!
```
передача обьекта user, функции sayHi, в функцию settimeout  
Происходит на примере таймаута это потому что в this таймаута передалась this = window, и при вызове this пытается обратиться как window.firstname, чего не существует.  
## Решение рпоблемы 1. Функция обёртка  
Оборачивание функции в анонимную функция создав замыкание.  
```javascript
let user = {
    firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
}

setTimeout(function() {
  user.sayHi();
}, 1000);
setTimeout(() => user.sayHi(), 1000); // Привет, Вася!
///////////////////////////////////////////////////////////////////


// ...в течение 1 секунды
user = { sayHi() { alert("Другой пользователь в 'setTimeout'!"); } };
```  
обьект user Достаётся из замыкания затем вызывая метод sayhi.  
Однако теперь появилась проблема, если за время таймаута произойдёт изменение обьекта, вернётся не нужное значение обьекта(вася), а поменяное.  
## Решение 2. Привязка при помощи bind 
Метод bind позволяет зафиксировать this.  
``let boundFunc = func.bind(context)``  
Результатом вызова является особый обьект, который вызывается как функция и передаёт вызов в func, при этом устанавливая this = context.
```javascript
let user = {
  firstName: "Вася"
};
function func() {
  alert(this.firstName);
}
// в funcuser запоминается текущее this
let funcUser = func.bind(user);
funcUser(); // Вася
```  
Рещение проблемы
```javascript
let user = {
  firstName: "Вася",
  sayHi() {
    alert(`Привет, ${this.firstName}!`);
  }
};
let sayHi = user.sayHi.bind(user); // привязка метода sayhi
sayHi(); // Привет, Вася!
setTimeout(sayHi, 1000); // Привет, Вася!
// передались параметры setTimeout но контекст бинда this остался неизменным
```  
## Частичное применение  
Полный функционал bind заключается еще и в привязке каких либо аргументов, т.е. полный синтаксис будет ``func.bind(context, [arg1], [arg2], ...)``
```javascript
// функция умножения на 2
function mul(a, b) {
  return a * b;
}
let double = mul.bind(null, 2)
console.log(double(3)) // mul(2, 3) = 6
```
вызов null.bind(null, 2); создаёт новую функцию double которая передаёт вызов mul задавая фиксируя null как контекст и 2 как первый аргумент, остальное передаётся как есть.  
Польза от таких манипуляций когда нужно создать независимую функцию повсеместно применимую с одинаковыми аргументами.
## Частичное применнение без контекста 
Задача стоит в фиксировании аргументов без контекста this, во встроенном bind так сделать нельзя, все сделать можно только в ручную  
```javascript
// функция - фиксатор аргументов 
function partial(func, ...argsBound) {
  return function(...args){
    return func.call(this, ...argsBound, ...args);
  }
}
let user = {
  firstName: "John",
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());
user.sayNow('hi');
// [10:00] John: hi!
```

