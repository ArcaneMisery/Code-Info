# Остаточные параметры. Оператор расширения
## Остаточные параметры [...]  
Работает это так что [...args] собирает все переданные в функцию данные в массив.
```javascript
function sumAll(...args) {
  let sum = 0;

  for (let arg of args) sum += arg;
  return sum;
}
console.log( sumAll(1));
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6
```
Можно использовать так чтобы сложить несколько данных в переменные а остальное в массив
```javascript
function showName(firstName, lastName, ...titles) {
  console.log(firstNmae + '' + lastName);
}
showName("Юлий", "Цезарь", "Консул", "Император");
// Консул и Исператор собрались в массив titles
```
**ОСТАТОЧНЫЕ ПАРАМЕТРЫ ОБЯЗАТЕЛЬНО ДОЛЖНЫ РАСПОЛАГАТЬСЯ В КОНЦЕ**

## Не много про arguments  
Все аргументы функции находятся в псевдомассиве(обьекте) arguments
(practic/js важные пометки):
**Стрелочные функции не имеют arguments**
## Оператор расширения  
Получает список параметров из массив (абсолютно наооборот в отличии от предыдущего)
```javascript
let a = [3, 5 ,1];
console.log(Math.max(...a))// 5 оператор раскрыл значения массива

// можно передать несколько итерируемых обьектов
let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
console.log(Math.max(...arr1, ...arr2)); 

// можно комбинировать с обычными значениями

let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];
console.log(Math.max(6, ...arr1, 1, ...arr2, 25)); 

// Можно использовать для слияния массивов

let arr = [3, 5, 1];
let arr2 = [8, 9, 15];
let merged = [0, ...arr, 2, ...arr2];
console.log(merged) //0,3,5,1,2,8,9,15 (0, затем arr, затем 2, в конце arr2)

// превращение строки в массив

let str = "Привет";
// Array.from преобразует перебираемый объект в массив
alert( [...str] ); // П,р,и,в,е,т
```
**Оператор расширения практически безграничен и работает с любым перебираемым обьектом**  
**Как это работает**  
Оператор расширения использует итераторы чтобы перебирать элементы как цикл for of.  
По сути ...obj работает идентично Array.from(obj). Но есть одно важное отличие.  
+ ``Array.from(obj)`` работает как с итерируемыми обьектами так и с псевдомассивами  
+ Оператор расширения работает только с итерируемыми обьектами 

# Обьект функции, NFE 
В js функции это обьект и как и у обычных обьектов у функций тоже есть ствой свойтсва.
## свойство name
func.name - получает имя функции либо название переменной в которую она записана
```javascript
function sayHi = function() {
  console.log('Hi');
}
let sayHi = function(){

}
console.log(sayHi.name) // в обоих случаях присвоится имя sayHi

function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (работает!)
}
f();
```
Такой манёвр когда не задано имя функции называется **контекстным имя** js пытается определить имя из контекста    
Имена имеют и методы обьекта
```javascript
let user = {

  sayHi(){
  },
  sayBye: function() {
    //...
  }
} 
console.log(user.sayHi.name)// sayHi
console.log(user.sayBy.name)// sayBi
```
Однако может быть ситуация в которой конкретное имя определить невозможно
```javascript
let arr = [function() {}];
console.log(arr[0].name) // ''
// нет возможности определить имя так как его нет
```
## Свойство length
Возвращает количество параметров функции в её обьявлении
```javascript
function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
```
Остаточные параметры как бы не считаются в св-во length    
Зачастую это свойство используется в функциях которые работают с другими функциями
## Пользовательские свойства  
Можно создавать свои свойства для функций  
К примеру свойство для подсчета вызовов функции  
```javascript
function sayhi() {
  console.log('hi')

  sayHi.counter++
}
sayHi.counter = 0

sayHi(); // Hi
sayHi(); // Hi
console.log(sayHi.counter) // 2
```
**Свойство функции не есть переменная**, можно использовать функцию как обьект и хранить в ней свойства, но они ни как не влияют на её выполнение, свойства это не переменные и наоборот это два парралельных мира.  

## Named Function Expression  
NFE - это термин для function expression у которого есть имя  
Проще говоря это задание имени функции когда функция складывается в переменную, нужно это для того чтобы безопасно делать самовызовы функции, ибо если делать такие вызовы через переменную функции, переменная может изменится и код вызовет ошибку  
# Синтаксис new function
Еще один вариант вызова функции
``let func = new function([arg1,arg2,...argN], body)``  
Главное отличие такого подхода в том что функция создаётся в момент чтения из строки, переданной во время выполнения.  
new function может превратить любую строку в функцию, к примеру передана функция строкой
```javascript
let str = '....' // код полученнй с сервера
let func = new function(str);
func();
```
## из темы замыкания  
Функции запоминают где были созданы с помощью свойства enviroment, но функции обьявленные в new дествуют наоборот, в их enviroment записывается ссылка на внешнее лексическое пространство.Поэтому они не могут использовать внешние локальные переменные. Но это очень хорошо, потому что страхует нас от ошибок. Переданные явно параметры – гораздо лучшее архитектурное решение, которое не вызывает проблем у минификаторов.